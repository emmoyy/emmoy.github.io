{"meta":{"title":"Tian-Xing's blog","subtitle":null,"description":null,"author":"Tian-Xing","url":"https://tian-xing.github.io","root":"/"},"pages":[{"title":"关于","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-20T03:18:24.878Z","comments":false,"path":"about/index.html","permalink":"https://tian-xing.github.io/about/index.html","excerpt":"","text":"[Tian-Xing's blog] 与&nbsp; Tian-Xing&nbsp; （ 您好（こんにちは） ） 对话中... bot_ui_ini()"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-08-27T23:07:21.473Z","comments":false,"path":"client/index.html","permalink":"https://tian-xing.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-08-27T23:07:21.492Z","comments":true,"path":"comment/index.html","permalink":"https://tian-xing.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-08-27T23:07:21.511Z","comments":false,"path":"donate/index.html","permalink":"https://tian-xing.github.io/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-08-27T23:07:21.531Z","comments":false,"path":"lab/index.html","permalink":"https://tian-xing.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-08-27T23:07:21.455Z","comments":false,"path":"bangumi/index.html","permalink":"https://tian-xing.github.io/bangumi/index.html","excerpt":"","text":""},{"title":"友链","date":"2018-12-19T15:11:06.000Z","updated":"2019-11-09T12:11:33.061Z","comments":true,"path":"links/index.html","permalink":"https://tian-xing.github.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-09T06:26:40.568Z","updated":"2019-09-27T16:29:46.000Z","comments":true,"path":"live2d/README.html","permalink":"https://tian-xing.github.io/live2d/README.html","excerpt":"","text":"Live2D Widget特性 Feature在网页中添加Live2D看板娘。与PJAX兼容，支持无刷新加载。Add Live2D widget to web page. Compatible with PJAX. 警告：不支持IE。WARNING: DO NOT SUPPORT IE. 示例 Demo在米米的博客的左下角可查看效果。需要使用支持WebGL的现代浏览器浏览。 这个仓库中也提供了两个Demo，即 demo1.html ，展现基础效果 demo2.html ，仿NPM的登陆界面 依赖 Dependencies本插件需要jQuery和font-awesome支持，请确保它们已在页面中加载，例如在&lt;head&gt;中加入：jQuery and font-awesome is required for this plugin. You can add this to &lt;head&gt;: &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt; 否则无法正常显示。（如果你的网页已经加载了jQuery，就不要重复加载了） 使用 Usage你可以直接这样使用： &lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 将这一行代码加入&lt;head&gt;或&lt;body&gt;，即可看到效果。如果你的网站启用了PJAX，由于看板娘不必每页刷新，因此需要注意将相关脚本放到PJAX刷新区域之外。 换句话说，如果你是小白，或者只需要最基础的功能，就只需要： 把这一行代码，连同前面的两行代码，一起放到html的&lt;head&gt;中即可； 如果页面是用各种模版引擎、php、asp生成的，也要自行修改，方法类似，只是可能略为麻烦。 但是！我们强烈推荐自己进行配置，否则很多功能是不完整的，并且可能产生问题！如果你有兴趣自己折腾的话，请看下面的详细说明。 Using CDN如果要自定义有关内容，可以把这个仓库Fork一份，然后进行修改。这时，使用方法对应地变为 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/username/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 将username替换为你的GitHub用户名即可。 Self-host你也可以直接把这些文件放到服务器上，而不是通过CDN加载。 如果你可以通过ssh访问你的主机，请把整个项目克隆到服务器上。执行：cd /path/to/your/webroot # Clone this repository git clone https://github.com/stevenjoezhang/live2d-widget.git 如果你的主机无法用ssh连接（例如一般的虚拟主机），请选择Download ZIP，然后通过ftp上传到主机上，再解压到网站的目录下。 如果你是通过Hexo等工具部署的静态博客，请选择Download ZIP，然后解压到本地的博客目录下，例如source下与_posts同级的目录。重新部署博客时，相关文件就会自动上传到对应的目录。（还需要在Hexo主题相关的swig或ejs模版中正确配置路径，才可以加载） 这样，整个项目就可以通过你的服务器IP或者域名从公网访问了。你可以试试能否正常地通过浏览器打开autoload.js和live2d.min.js等文件。（最好还要确定一下这些文件的内容是正确的，有时由于字符集的问题，文件中可能出现乱码；此时需要重新下载）如果没有问题，接下来需要修改一些配置。（需要通过服务器上的vim，emacs，cPanel文件管理器等工具修改；你也可以先在本地完成这一步骤，再上传到服务器上）修改autoload.js中的参数live2d_path为live2d-widget这一文件夹在公网上的路径。比如说，如果你可以通过 https://www.example.com/path/to/live2d-widget/live2d.min.js访问到live2d.min.js，那么就把live2d_path的值修改为 https://www.example.com/path/to/live2d-widget/路径末尾的/一定要加上。具体可以参考autoload.js内的注释。完成后，在你要添加看板娘的界面加入 &lt;script src=&quot;https://www.example.com/path/to/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 就可以加载了。 目录结构 Files waifu-tips.json中包含了触发条件（selector，选择器）和触发时显示的文字（text）； waifu.css是看板娘的样式表。 源文件是对Hexo的NexT主题有效的，为了适用于你自己的网页，可能需要自行修改，或增加新内容。警告：作者不对包括但不限于waifu-tips.json和waifu-tips.js文件中的内容负责，请自行确保它们是合适的。 如果有任何疑问，欢迎提Issue。如果有任何修改建议，欢迎提PR。 鸣谢 Credits代码自这篇博文魔改而来：https://www.fghrsh.net/post/123.html相比初始的版本，这个仓库增加了一些功能，并优化了提示展现机制。 更多内容可以参考：https://zhangshuqiao.org/2018-07/在网页中添加Live2D看板娘/https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02https://github.com/summerscar/live2dDemo 还可以自行搭建后端api，并增加模型（需要修改的内容比较多，此处不再赘述）：https://github.com/fghrsh/live2d_apihttps://github.com/xiazeyu/live2d-widget-modelshttps://github.com/xiaoski/live2d_models_collection 除此之外，还有桌面版本：https://github.com/amorist/platelethttps://github.com/akiroz/Live2D-Widget 另外，点击看板娘的纸飞机按钮，会出现一个彩蛋，这来自于WebsiteAsteroids。 更多 MoreLive2D官方网站：https://www.live2d.com/en/https://live2d.github.io 可以在官方网站下载、打包SDK，以获取更多的功能。具体操作是： 点击Cubism SDK for Web，下载相关文件； 解压并进入目录，执行npm install； 执行npm run build-sample。 许可证 LicenseReleased under the GNU General Public License v3http://www.gnu.org/licenses/gpl-3.0.html 更新 Update2018年10月31日，由fghrsh提供的原API停用，请更新至新地址。参考文章：https://www.fghrsh.net/post/170.html"},{"title":"","date":"2019-11-09T06:26:40.620Z","updated":"2019-09-27T16:29:46.000Z","comments":true,"path":"live2d/waifu-tips.js","permalink":"https://tian-xing.github.io/live2d/waifu-tips.js","excerpt":"","text":"/* * https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02 * https://www.fghrsh.net/post/123.html */ function loadWidget(waifuPath, apiPath) { localStorage.removeItem(\"waifu-display\"); sessionStorage.removeItem(\"waifu-text\"); $(\"body\").append(` `); $(\"#waifu\").show().animate({ bottom: 0 }, 3000); function registerEventListener() { $(\"#waifu-tool .fa-comment\").click(showHitokoto); $(\"#waifu-tool .fa-paper-plane\").click(() => { if (window.Asteroids) { if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = []; window.ASTEROIDSPLAYERS.push(new Asteroids()); } else { $.ajax({ url: \"https://cdn.jsdelivr.net/gh/GalaxyMimi/CDN/asteroids.js\", dataType: \"script\", cache: true }); } }); $(\"#waifu-tool .fa-user-circle\").click(loadOtherModel); $(\"#waifu-tool .fa-street-view\").click(loadRandModel); $(\"#waifu-tool .fa-camera-retro\").click(() => { showMessage(\"照好了嘛，是不是很可爱呢？\", 6000, 9); Live2D.captureName = \"photo.png\"; Live2D.captureFrame = true; }); $(\"#waifu-tool .fa-info-circle\").click(() => { open(\"https://github.com/stevenjoezhang/live2d-widget\"); }); $(\"#waifu-tool .fa-times\").click(() => { localStorage.setItem(\"waifu-display\", new Date().getTime()); showMessage(\"愿你有一天能与重要的人重逢。\", 2000, 11); $(\"#waifu\").animate({ bottom: -500 }, 3000, () => { $(\"#waifu\").hide(); $(\"#waifu-toggle\").show().animate({ \"margin-left\": -50 }, 1000); }); }); var re = /x/; console.log(re); re.toString = () => { showMessage(\"哈哈，你打开了控制台，是想要看看我的小秘密吗？\", 6000, 9); return \"\"; }; $(document).on(\"copy\", () => { showMessage(\"你都复制了些什么呀，转载要记得加上出处哦！\", 6000, 9); }); $(document).on(\"visibilitychange\", () => { if (!document.hidden) showMessage(\"哇，你终于回来了～\", 6000, 9); }); } registerEventListener(); function welcomeMessage() { var SiteIndexUrl = location.port ? `${location.protocol}//${location.hostname}:${location.port}/` : `${location.protocol}//${location.hostname}/`, text; //自动获取主页 if (location.href == SiteIndexUrl) { //如果是主页 var now = new Date().getHours(); if (now > 5 && now 7 && now 11 && now 14 && now 17 && now 19 && now 21 && now { userAction = true; }).keydown(() => { userAction = true; }); setInterval(() => { if (!userAction) { if (!hitokotoTimer) hitokotoTimer = setInterval(showHitokoto, 25000); } else { userAction = false; clearInterval(hitokotoTimer); hitokotoTimer = null; } }, 1000); function showHitokoto() { //增加 hitokoto.cn 的 API if (Math.random() < 0.6 && messageArray.length > 0) showMessage(messageArray[Math.floor(Math.random() * messageArray.length)], 6000, 9); else $.getJSON(\"https://v1.hitokoto.cn\", function(result) { var text = `这句一言来自 『${result.from}』，是 ${result.creator} 在 hitokoto.cn 投稿的。`; showMessage(result.hitokoto, 6000, 9); setTimeout(() => { showMessage(text, 4000, 9); }, 6000); }); } function showMessage(text, timeout, priority) { if (!text) return; if (!sessionStorage.getItem(\"waifu-text\") || sessionStorage.getItem(\"waifu-text\") { sessionStorage.removeItem(\"waifu-text\"); $(\"#waifu-tips\").fadeTo(1000, 0); }, timeout); } } function initModel() { var modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId == null) { //首次访问加载 指定模型 的 指定材质 var modelId = 1, //模型 ID modelTexturesId = 53; //材质 ID } loadModel(modelId, modelTexturesId); $.getJSON(waifuPath, function(result) { $.each(result.mouseover, function(index, tips) { $(document).on(\"mouseover\", tips.selector, function() { var text = Array.isArray(tips.text) ? tips.text[Math.floor(Math.random() * tips.text.length)] : tips.text; text = text.replace(\"{text}\", $(this).text()); showMessage(text, 4000, 8); }); }); $.each(result.click, function(index, tips) { $(document).on(\"click\", tips.selector, function() { var text = Array.isArray(tips.text) ? tips.text[Math.floor(Math.random() * tips.text.length)] : tips.text; text = text.replace(\"{text}\", $(this).text()); showMessage(text, 4000, 8); }); }); $.each(result.seasons, function(index, tips) { var now = new Date(), after = tips.date.split(\"-\")[0], before = tips.date.split(\"-\")[1] || after; if ((after.split(\"/\")[0]"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-08-27T23:07:21.586Z","comments":true,"path":"rss/index.html","permalink":"https://tian-xing.github.io/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-08-27T23:07:21.568Z","comments":false,"path":"music/index.html","permalink":"https://tian-xing.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-20T01:54:09.681Z","comments":true,"path":"tags/index.html","permalink":"https://tian-xing.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-08-27T23:07:21.624Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://tian-xing.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"","date":"2019-11-09T06:45:05.931Z","updated":"2019-11-09T06:45:05.931Z","comments":true,"path":"live2d/autoload.js","permalink":"https://tian-xing.github.io/live2d/autoload.js","excerpt":"","text":"//注意：live2d_path参数应使用绝对路径 const live2d_path=\"/live2d/\"; //const live2d_path = \"/live2d-widget/\"; //加载waifu.css $(\"\").attr({ href: live2d_path + \"waifu.css\", rel: \"stylesheet\" }).appendTo(\"head\"); //加载live2d.min.js $.ajax({ url: live2d_path + \"live2d.min.js\", dataType: \"script\", cache: true }); //加载waifu-tips.js $.ajax({ url: live2d_path + \"waifu-tips.js\", dataType: \"script\", cache: true }); //初始化看板娘，会自动加载指定目录下的waifu-tips.json $(window).on(\"load\", function() { initWidget(live2d_path + \"waifu-tips.json\", \"https://live2d.fghrsh.net/api\"); }); //initWidget第一个参数为waifu-tips.json的路径 //第二个参数为api地址（无需修改） //api后端可自行搭建，参考https://github.com/fghrsh/live2d_api console.log(` く__,.ヘヽ. / ,ー､ 〉 ＼ ', !-─‐-i / /´ ／｀ｰ' L/／｀ヽ､ / ／, /| , , ', ｲ / /-‐/ ｉ L_ ﾊ ヽ! i ﾚ ﾍ 7ｲ｀ﾄ ﾚ'ｧ-ﾄ､!ハ| | !,/7 '0' ´0iソ| | |.从\" _ ,,,, / |./ | ﾚ'| i＞.､,,__ _,.イ / .i | ﾚ'| | / k_７_/ﾚ'ヽ, ﾊ. | | |/i 〈|/ i ,.ﾍ | i | .|/ / ｉ： ﾍ! ＼ | kヽ>､ﾊ _,.ﾍ､ /､! !'〈//｀Ｔ´', ＼ ｀'7'ｰr' ﾚ'ヽL__|___i,___,ンﾚ|ノ ﾄ-,/ |___./ 'ｰ' !_,.: `);"},{"title":"","date":"2019-11-09T06:41:32.144Z","updated":"2019-11-09T06:41:32.144Z","comments":true,"path":"live2d/waifu.css","permalink":"https://tian-xing.github.io/live2d/waifu.css","excerpt":"","text":"#waifu-toggle { position: fixed; writing-mode: vertical-rl; bottom: 66px; left: 0px; background-color: #fa0; color: #fff; border-radius: 5px; padding: 5px 2px 5px 5px; font-size: 12px; width: 60px; cursor: pointer; } #waifu { position: fixed; bottom: 350px; left: 100px; z-index: 1; line-height: 0; transition: transform .3s ease-in-out; transform: translateY(3px); } #waifu:hover { transform: translateY(0); } @media (max-width: 768px) { #waifu { display: none; } } #waifu-tips { opacity: 0; width: 250px; min-height: 70px; margin: -30px 20px; padding: 5px 10px; border: 1px solid rgba(224, 186, 140, 0.62); border-radius: 12px; background-color: rgba(236, 217, 188, 0.5); box-shadow: 0 3px 15px 2px rgba(191, 158, 118, 0.2); font-size: 14px; line-height: 24px; word-break: break-all; text-overflow: ellipsis; overflow: hidden; position: absolute; animation: shake 50s ease-in-out 5s infinite; } #waifu #live2d { position: relative; cursor: grab; cursor: -webkit-grab; cursor: -o-grab; cursor: -ms-grab; } #waifu #live2d:active { cursor: grabbing; cursor: -webkit-grabbing; cursor: -o-grabbing; cursor: -ms-grabbing; } #waifu-tool { color: #aaa; top: 70px; right: -10px; position: absolute; opacity: 0; transition: opacity 1s; } #waifu:hover #waifu-tool { opacity: 1; } #waifu-tool span { display: block; cursor: pointer; line-height: 30px; text-align: center; color: #5b6c7d; transition: color .3s; } #waifu-tool span:hover { color: #0684bd;/* #34495e */ } @keyframes shake { 2% { transform: translate(0.5px, -1.5px) rotate(-0.5deg); } 4% { transform: translate(0.5px, 1.5px) rotate(1.5deg); } 6% { transform: translate(1.5px, 1.5px) rotate(1.5deg); } 8% { transform: translate(2.5px, 1.5px) rotate(0.5deg); } 10% { transform: translate(0.5px, 2.5px) rotate(0.5deg); } 12% { transform: translate(1.5px, 1.5px) rotate(0.5deg); } 14% { transform: translate(0.5px, 0.5px) rotate(0.5deg); } 16% { transform: translate(-1.5px, -0.5px) rotate(1.5deg); } 18% { transform: translate(0.5px, 0.5px) rotate(1.5deg); } 20% { transform: translate(2.5px, 2.5px) rotate(1.5deg); } 22% { transform: translate(0.5px, -1.5px) rotate(1.5deg); } 24% { transform: translate(-1.5px, 1.5px) rotate(-0.5deg); } 26% { transform: translate(1.5px, 0.5px) rotate(1.5deg); } 28% { transform: translate(-0.5px, -0.5px) rotate(-0.5deg); } 30% { transform: translate(1.5px, -0.5px) rotate(-0.5deg); } 32% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 34% { transform: translate(2.5px, 2.5px) rotate(-0.5deg); } 36% { transform: translate(0.5px, -1.5px) rotate(0.5deg); } 38% { transform: translate(2.5px, -0.5px) rotate(-0.5deg); } 40% { transform: translate(-0.5px, 2.5px) rotate(0.5deg); } 42% { transform: translate(-1.5px, 2.5px) rotate(0.5deg); } 44% { transform: translate(-1.5px, 1.5px) rotate(0.5deg); } 46% { transform: translate(1.5px, -0.5px) rotate(-0.5deg); } 48% { transform: translate(2.5px, -0.5px) rotate(0.5deg); } 50% { transform: translate(-1.5px, 1.5px) rotate(0.5deg); } 52% { transform: translate(-0.5px, 1.5px) rotate(0.5deg); } 54% { transform: translate(-1.5px, 1.5px) rotate(0.5deg); } 56% { transform: translate(0.5px, 2.5px) rotate(1.5deg); } 58% { transform: translate(2.5px, 2.5px) rotate(0.5deg); } 60% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 62% { transform: translate(-1.5px, 0.5px) rotate(1.5deg); } 64% { transform: translate(-1.5px, 1.5px) rotate(1.5deg); } 66% { transform: translate(0.5px, 2.5px) rotate(1.5deg); } 68% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 70% { transform: translate(2.5px, 2.5px) rotate(0.5deg); } 72% { transform: translate(-0.5px, -1.5px) rotate(1.5deg); } 74% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 76% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 78% { transform: translate(-1.5px, 2.5px) rotate(0.5deg); } 80% { transform: translate(-1.5px, 0.5px) rotate(-0.5deg); } 82% { transform: translate(-1.5px, 0.5px) rotate(-0.5deg); } 84% { transform: translate(-0.5px, 0.5px) rotate(1.5deg); } 86% { transform: translate(2.5px, 1.5px) rotate(0.5deg); } 88% { transform: translate(-1.5px, 0.5px) rotate(1.5deg); } 90% { transform: translate(-1.5px, -0.5px) rotate(-0.5deg); } 92% { transform: translate(-1.5px, -1.5px) rotate(1.5deg); } 94% { transform: translate(0.5px, 0.5px) rotate(-0.5deg); } 96% { transform: translate(2.5px, -0.5px) rotate(-0.5deg); } 98% { transform: translate(-1.5px, -1.5px) rotate(-0.5deg); } 0%, 100% { transform: translate(0, 0) rotate(0deg); } }"},{"title":"","date":"2019-11-09T06:26:40.655Z","updated":"2019-09-27T16:29:46.000Z","comments":true,"path":"live2d/waifu-tips.json","permalink":"https://tian-xing.github.io/live2d/waifu-tips.json","excerpt":"","text":"{\"mouseover\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"干嘛呢你，快把手拿开～～\",\"鼠…鼠标放错地方了！\",\"你要干嘛呀？\",\"喵喵喵？\",\"怕怕(ノ≧∇≦)ノ\",\"非礼呀！救命！\",\"这样的话，只能使用武力了！\",\"我要生气了哦\",\"不要动手动脚的！\",\"真…真的是不知羞耻！\",\"Hentai！\"]},{\"selector\":\"#waifu-tool .fa-comment\",\"text\":[\"猜猜我要说些什么？\",\"我从青蛙王子那里听到了不少人生经验。\"]},{\"selector\":\"#waifu-tool .fa-paper-plane\",\"text\":[\"要不要来玩飞机大战？\",\"这个按钮上写着“不要点击”。\",\"怎么，你想来和我玩个游戏？\",\"听说这样可以蹦迪！\"]},{\"selector\":\"#waifu-tool .fa-user-circle\",\"text\":[\"你是不是不爱人家了呀，呜呜呜～\",\"要见见我的姐姐嘛？\",\"想要看我妹妹嘛？\",\"要切换看板娘吗？\"]},{\"selector\":\"#waifu-tool .fa-street-view\",\"text\":[\"喜欢换装 PLAY 吗？\",\"这次要扮演什么呢？\",\"变装！\",\"让我们看看接下来会发生什么！\"]},{\"selector\":\"#waifu-tool .fa-camera-retro\",\"text\":[\"你要给我拍照呀？一二三～茄子～\",\"要不，我们来合影吧！\",\"保持微笑就好了～\"]},{\"selector\":\"#waifu-tool .fa-info-circle\",\"text\":[\"想要知道更多关于我的事么？\",\"这里记录着我搬家的历史呢。\",\"你想深入了解我什么呢？\"]},{\"selector\":\"#waifu-tool .fa-times\",\"text\":[\"到了要说再见的时候了吗？\",\"呜呜 QAQ 后会有期……\",\"不要抛弃我呀……\",\"我们，还能再见面吗……\",\"哼，你会后悔的！\"]},{\"selector\":\".menu-item-home\",\"text\":[\"点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\",\"点它就可以回到首页啦！\",\"回首页看看吧。\"]},{\"selector\":\".menu-item-about\",\"text\":[\"你想知道我家主人是谁吗？\",\"这里有一些关于我家主人的秘密哦，要不要看看呢？\",\"发现主人出没地点！\"]},{\"selector\":\".menu-item-tags\",\"text\":[\"点击就可以看文章的标签啦！\",\"点击来查看所有标签哦。\",\"快看看这里都有什么呢！\"]},{\"selector\":\".menu-item-categories\",\"text\":[\"文章都分类好啦～\",\"点击来查看文章分类哦。\",\"快看看这里都有什么呢！\"]},{\"selector\":\".menu-item-archives\",\"text\":[\"翻页比较麻烦吗，那就来看看文章归档吧。\",\"文章目录都整理在这里啦！\",\"快看看这里都有什么呢？\"]},{\"selector\":\".menu-item-friends\",\"text\":[\"这是我的朋友们哦ヾ(◍°∇°◍)ﾉﾞ\",\"要去大佬们的家看看吗？\",\"要去拜访一下我的朋友们吗？\"]},{\"selector\":\".menu-item-search\",\"text\":[\"找不到想看的内容？搜索看看吧！\",\"在找什么东西呢，需要帮忙吗？\"]},{\"selector\":\".site-author\",\"text\":[\"我家主人好看吗？\",\"这是我家主人(*´∇｀*)\"]},{\"selector\":\".site-state\",\"text\":[\"这是文章的统计信息～\",\"要不要点进去看看？\"]},{\"selector\":\".feed-link a\",\"text\":[\"这里可以使用 RSS 订阅呢！\",\"利用 feed 订阅器，就能快速知道博客有没有更新了呢。\"]},{\"selector\":\".cc-opacity, .post-copyright-author\",\"text\":[\"要记得规范转载哦。\",\"所有文章均采用 CC BY-NC-SA 4.0 许可协议～\",\"转载前要先注意下文章的版权协议呢。\"]},{\"selector\":\".links-of-author\",\"text\":[\"这里是主人的常驻地址哦。\",\"这里有主人的联系方式！\"]},{\"selector\":\"#qrcode\",\"text\":[\"手机扫一下就能继续看，很方便呢～\",\"扫一扫，打开新世界的大门！\"]},{\"selector\":\".fancybox img, img.medium-zoom-image\",\"text\":[\"点击图片可以放大呢！\"]},{\"selector\":\".highlight-wrap, .gist\",\"text\":[\"代码可以直接点击复制哟。\",\"GitHub！我是新手！\",\"PHP 是最好的语言！\"]},{\"selector\":\".container a[href^='http'], .nav-link .nav-text\",\"text\":[\"要去看看 {text} 么？\",\"去 {text} 逛逛吧。\",\"到 {text} 看看吧。\"]},{\"selector\":\"a[href^='mailto']\",\"text\":[\"邮件我会及时回复的！\",\"点击就可以发送邮件啦～\"]},{\"selector\":\"a[href^='/tags/']\",\"text\":[\"要去看看 {text} 标签么？\",\"点它可以查看此标签下的所有文章哟！\"]},{\"selector\":\"a[href^='/categories/']\",\"text\":[\"要去看看 {text} 分类么？\",\"点它可以查看此分类下的所有文章哟！\"]},{\"selector\":\".post-title-link\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\"a[rel='contents']\",\"text\":[\"点击来阅读全文哦。\"]},{\"selector\":\"a[itemprop='discussionUrl']\",\"text\":[\"要去看看评论吗？\"]},{\"selector\":\".back-to-top\",\"text\":[\"点它就可以回到顶部啦！\",\"又回到最初的起点～\",\"要回到开始的地方么？\"]},{\"selector\":\"#rewardButton\",\"text\":[\"我是不是棒棒哒～快给我点赞吧！\",\"要打赏我嘛？好期待啊～\",\"主人最近在吃土呢，很辛苦的样子，给他一些钱钱吧～\"]},{\"selector\":\"#wechat\",\"text\":[\"这是我的微信二维码～\"]},{\"selector\":\"#alipay\",\"text\":[\"这是我的支付宝哦！\"]},{\"selector\":\"#bitcoin\",\"text\":[\"这是我的比特币账号！\"]},{\"selector\":\"#needsharebutton-postbottom .btn\",\"text\":[\"好东西要让更多人知道才行哦。\",\"觉得文章有帮助的话，可以分享给更多需要的朋友呢。\"]},{\"selector\":\".need-share-button_weibo\",\"text\":[\"微博？来分享一波喵！\"]},{\"selector\":\".need-share-button_wechat\",\"text\":[\"分享到微信吧！\"]},{\"selector\":\".need-share-button_douban\",\"text\":[\"分享到豆瓣好像也不错！\"]},{\"selector\":\".need-share-button_qqzone\",\"text\":[\"QQ空间，一键转发，耶～\"]},{\"selector\":\".need-share-button_twitter\",\"text\":[\"Twitter？好像是不存在的东西？\"]},{\"selector\":\".need-share-button_facebook\",\"text\":[\"emmm…FB好像也是不存在的东西？\"]},{\"selector\":\".post-nav-next\",\"text\":[\"来看看下一篇文章吧。\",\"点它可以看下一篇文章哦！\",\"要翻到下一篇文章吗？\"]},{\"selector\":\".post-nav-prev\",\"text\":[\"来看看上一篇文章吧。\",\"点它可以看上一篇文章哦！\",\"要翻到上一篇文章吗？\"]},{\"selector\":\".extend.next\",\"text\":[\"去下一页看看吧。\",\"点它可以前进哦！\",\"要翻到下一页吗？\"]},{\"selector\":\".extend.prev\",\"text\":[\"去上一页看看吧。\",\"点它可以后退哦！\",\"要翻到上一页吗？\"]},{\"selector\":\"input.vnick\",\"text\":[\"该怎么称呼你呢？\",\"留下你的尊姓大名！\"]},{\"selector\":\".vmail\",\"text\":[\"留下你的邮箱，不然就是无头像人士了！\",\"记得设置好 Gravatar 头像哦！\",\"为了方便通知你最新消息，一定要留下邮箱！\"]},{\"selector\":\".vlink\",\"text\":[\"快快告诉我你的家在哪里，好让我去参观参观！\"]},{\"selector\":\".veditor\",\"text\":[\"想要去评论些什么吗？\",\"要说点什么吗？\",\"觉得博客不错？快来留言和主人交流吧！\"]},{\"selector\":\".vcontrol a\",\"text\":[\"你会不会熟练使用Markdown呀？\",\"使用Markdown让评论更美观吧～\"]},{\"selector\":\".vemoji-btn\",\"text\":[\"要插入一个萌萌哒的表情吗？\",\"要来一发表情吗？\"]},{\"selector\":\".vpreview-btn\",\"text\":[\"要预览一下你的发言吗？\",\"快看看你的评论有多少负熵！\"]},{\"selector\":\".vsubmit\",\"text\":[\"评论没有审核，要对自己的发言负责哦～\",\"要提交了吗，请耐心等待回复哦～\"]},{\"selector\":\".vcontent\",\"text\":[\"哇，快看看这个精彩评论！\",\"如果有疑问，请尽快留言哦～\"]}],\"click\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"是…是不小心碰到了吧…\",\"萝莉控是什么呀？\",\"你看到我的小熊了吗？\",\"再摸的话我可要报警了！⌇●﹏●⌇\",\"110吗，这里有个变态一直在摸我(ó﹏ò｡)\",\"不要摸我了，我会告诉老婆来打你的！\",\"干嘛动我呀！小心我咬你！\",\"别摸我，有什么好摸的！\"]},{\"selector\":\".veditor\",\"text\":[\"要吐槽些什么呢？\",\"一定要认真填写喵～\",\"有什么想说的吗？\"]},{\"selector\":\".vsubmit\",\"text\":[\"输入验证码就可以提交评论啦～\"]}],\"seasons\":[{\"date\":\"01/01\",\"text\":\"元旦了呢，新的一年又开始了，今年是{year}年～\"},{\"date\":\"02/14\",\"text\":\"又是一年情人节，{year}年找到对象了嘛～\"},{\"date\":\"03/08\",\"text\":\"今天是妇女节！\"},{\"date\":\"03/12\",\"text\":\"今天是植树节，要保护环境呀！\"},{\"date\":\"04/01\",\"text\":\"悄悄告诉你一个秘密～今天是愚人节，不要被骗了哦～\"},{\"date\":\"05/01\",\"text\":\"今天是五一劳动节，计划好假期去哪里了吗～\"},{\"date\":\"06/01\",\"text\":\"儿童节了呢，快活的时光总是短暂，要是永远长不大该多好啊…\"},{\"date\":\"07/08\",\"text\":\"2018 年是多久之前来着……1，2，3……有好多好多天呢！我到主人家这么久啦\"},{\"date\":\"08/17\",\"text\":\"难道，是那位大人降临的日子！\"},{\"date\":\"09/03\",\"text\":\"中国人民抗日战争胜利纪念日，铭记历史、缅怀先烈、珍爱和平、开创未来。\"},{\"date\":\"09/10\",\"text\":\"教师节，在学校要给老师问声好呀～\"},{\"date\":\"10/01\",\"text\":\"国庆节到了，为祖国母亲庆生！\"},{\"date\":\"11/05-11/12\",\"text\":\"今年的双十一是和谁一起过的呢～\"},{\"date\":\"12/20-12/31\",\"text\":\"这几天是圣诞节，主人肯定又去剁手买买买了～\"}]}"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-08-27T23:07:21.668Z","comments":false,"path":"video/index.html","permalink":"https://tian-xing.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"},{"title":"","date":"2019-11-09T06:26:40.598Z","updated":"2019-09-27T16:29:46.000Z","comments":true,"path":"live2d/demo/demo2.html","permalink":"https://tian-xing.github.io/live2d/demo/demo2.html","excerpt":"","text":"看板娘登陆平台 html, body { height: 100%; } body { display: flex; align-items: center; justify-content: center; padding-top: 40px; padding-bottom: 40px; background-color: #f5f5f5; } .form-signin { width: 100%; max-width: 330px; padding: 15px; margin: 0 auto; } .form-signin .checkbox { font-weight: 400; } .form-signin .form-control { position: relative; box-sizing: border-box; height: auto; padding: 10px; font-size: 16px; } .form-signin .form-control:focus { z-index: 2; } .form-signin input[type=text] { margin-bottom: -1px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .form-signin input[type=password] { margin-bottom: 10px; border-top-left-radius: 0; border-top-right-radius: 0; } #stage { position: relative; } #stage img { width: 100%; margin-bottom: 20px; border-radius: 20px; } #stage a { position: absolute; width: 2em; height: 2em; border-radius: 50%; } #inner { position: relative; background-color: #999; clip-path: circle(120px at center); -webkit-clip-path: circle(120px at center); } #cover { position: absolute; background-color: #CB3837; width: 100%; height: 100%; bottom: 10%; transition: all 1s; box-shadow: 0 0 0 5px rgba(0, 0, 0, .1); } #text { position: absolute; bottom: 30%; font-size: 2em; left: 50%; transform: translateX(-50%); opacity: 0.4; font-weight: bold; } #detail { position: absolute; background: rgba(255, 255, 255, .1); width: 100%; height: 10px; bottom: 0; } #handle { position: absolute; background: #ccc; bottom: -2px; box-shadow: 0 1px 0 1px rgba(0, 0, 0, .1); height: 8px; left: 50%; margin-left: -15px; width: 30px; cursor: pointer; } #info { left: 40px; bottom: 20px; } #refresh { right: 40px; bottom: 20px; } #live2d { cursor: grab; } #live2d:active { cursor: grabbing; } MIMIPOWERED 看板娘登陆平台 用户名 密码 记住我 登录 Copyleft &copy; Mimi 2019 $(function() { \"use strict\"; if (!CSS.supports(\"clip-path\", \"circle(120px at center)\") && !CSS.supports(\"-webkit-clip-path\", \"circle(120px at center)\")) { $(\"#stage\").html(''); return; } var apiURL = \"https://live2d.fghrsh.net/api\", state = 0, modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId == null) { modelId = 1; modelTexturesId = 53; } loadModel(modelId, modelTexturesId); function loadModel(modelId, modelTexturesId) { localStorage.setItem(\"modelId\", modelId); if (modelTexturesId === undefined) modelTexturesId = 0; localStorage.setItem(\"modelTexturesId\", modelTexturesId); loadlive2d(\"live2d\", `${apiURL}/get/?id=${modelId}-${modelTexturesId}`, null); console.log(\"live2d\", `模型 ${modelId}-${modelTexturesId} 加载完成`); setTimeout(function() { $(\"#cover\").css(\"bottom\", \"80%\"); state = 2; }, 2000); } function loadRandModel() { var modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); $.ajax({ cache: false, url: `${apiURL}/rand_textures/?id=${modelId}-${modelTexturesId}`, dataType: \"json\", success: function(result) { loadModel(modelId, result.textures[\"id\"]); setTimeout(function() { state = 2; $(\"#cover\").css(\"bottom\", \"80%\"); $(\"#refresh\").attr(\"href\", \"javascript:refresh()\"); }, 1000); } }); } function loadOtherModel() { var modelId = localStorage.getItem(\"modelId\"); $.ajax({ cache: false, url: `${apiURL}/switch/?id=${modelId}`, dataType: \"json\", success: function(result) { loadModel(result.model[\"id\"]); } }); } window.info = function() { //Your code here... $.getJSON(\"https://v1.hitokoto.cn/\", function(data) { alert(\"『\" + data.hitokoto + \"』——\" + data.from); }); } window.refresh = function() { state = 0; $(\"#cover\").css(\"bottom\", \"10%\"); $(\"#refresh\").attr(\"href\", \"javascript:void(0)\"); setTimeout(loadRandModel, 1000); } $(\"#handle\").click(function() { if (state == 1) { state = 2; $(\"#cover\").css(\"bottom\", \"80%\"); } else if (state == 2) { state = 1; $(\"#cover\").css(\"bottom\", \"20%\"); } }); $(\"input[type=password]\").focus(function() { if (state == 2) { state = 1; $(\"#cover\").css(\"bottom\", \"20%\"); } }).blur(function() { if (state == 1) { state = 2; $(\"#cover\").css(\"bottom\", \"80%\"); } }); });"},{"title":"","date":"2019-11-09T06:26:40.596Z","updated":"2019-09-27T16:29:46.000Z","comments":true,"path":"live2d/demo/demo1.html","permalink":"https://tian-xing.github.io/live2d/demo/demo1.html","excerpt":"","text":"Live2D 看板娘 / Demo #github svg { transition: all 1s; fill: #222; color: #fff; position: absolute; top: 0; right: 0; border: 0; width: 80px; height: 80px; } #github:hover svg { width: 160px; height: 160px; }"},{"title":"","date":"2019-11-09T06:26:40.601Z","updated":"2019-09-27T16:29:46.000Z","comments":true,"path":"live2d/live2d.min.js","permalink":"https://tian-xing.github.io/live2d/live2d.min.js","excerpt":"","text":"!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p=\"\",i(i.s=4)}([function(t,i,e){\"use strict\";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id=\"\",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=\"PARAM_EYE_L_OPEN\",this.eyeID_R=\"PARAM_EYE_R_OPEN\"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t"}],"posts":[{"title":"洛谷P4707 重返现世","slug":"洛谷P4707 重返现世","date":"2020-01-20T12:37:47.000Z","updated":"2020-01-20T12:54:12.054Z","comments":true,"path":"2020/01/20/洛谷P4707 重返现世/","link":"","permalink":"https://tian-xing.github.io/2020/01/20/%E6%B4%9B%E8%B0%B7P4707%20%E9%87%8D%E8%BF%94%E7%8E%B0%E4%B8%96/","excerpt":"理解了好久$min-max$容斥","text":"理解了好久$min-max$容斥 DescriptionP4707 重返现世 Solution对于每种原料，如果我们能求出它们的期望出现时间，那么第$k$小的期望出现时间就是答案。因为在第$k$小的原料被收集之前，比它更早出现的原料已经被收集过了，第$k$小的原料就是第$k$个被收集到的原料。 第$k$小的原料其实就是第$n-k+1$大的原料，由于第$k$小和第$k$大都不好求，考虑$min-max$容斥。 $$kthmax(S)=\\sum_{T\\subseteq S}(-1)^{\\left|T\\right|-x}\\times\\binom{\\left|T\\right|-1}{x-1}min(T)$$ 考虑$min(T)$的求法，因为只要有一个原料收集到就行，所以收集到任何一个元素的概率是$\\frac{ \\sum_{ i \\in T } p_i }{ m }$。因为只有两种情况，一种是出现可以收集的原料，一种是不出现，所以这是一个伯努利试验。而伯努利试验的成功期望是成功的概率的倒数，所以$min(T)$就是$\\frac{ m }{ \\sum_{ i \\in T } p_i }$。 接下来考虑计算答案，因为这道题的$n$比较大，所以不能直接暴力枚举子集$T$，但经过观察，我们发现$m$的范围很小，所以我们计算出每个$min(T)$前面的系数，最后枚举所有的$min(T)$乘上系数。 设$dp_{i,j,k}$表示前$i$个原料，求第$k$大的原料期望出现时间，所有的出现任意一个原料的概率等于$j$的集合前面的系数之和。 考虑转移，如果当前第$i$个原料不在集合$T$中，那么假设我们把它丢掉，不会造成什么影响，$T$的原料个数也不会变，出现任意一个原料的概率也不会改变，所以要加上$dp_{i-1,j,k}$。 如果第$i$个原料在集合$T$中，这个时候我们把它丢掉，发现对集合$T$造成了影响，集合$T$中少了第$i$个原料，出现任意一个元素的概率发生了变化，得减去$p_i$。那么$dp$状态中的第三个下标$k$会不会发生变化呢？(肯定的，不然设它干啥)。 当前集合$T$的系数如下 $$\\binom{\\left|T\\right|-1}{k-1}(-1)^{\\left|T\\right|-k}$$ 根据组合数的性质，上面的式子等于 $$\\left[ \\binom{\\left|T\\right|-2}{k-1} + \\binom{\\left|T\\right|-2}{k-2}\\right] (-1)^{\\left|T\\right|-k}$$ $$=\\binom{\\left|T\\right|-2}{k-1}(-1)^{\\left|T\\right|-k} + \\binom{\\left|T\\right|-2}{k-2}(-1)^{\\left|T\\right|-k}$$ 观察前$i-1$个原料构成的大小为$\\left|T\\right|-1$的集合中选第$k$大的系数，可以得到 $$\\binom{\\left|T\\right|-2}{k-1}(-1)^{\\left|T\\right|-k-1}=-\\binom{\\left|T\\right|-2}{k-1}(-1)^{\\left|T\\right|-k}$$ 观察前$i-1$个原料构成的大小为$\\left|T\\right|-1$的集合中选第$k-1$大的系数，可以得到 $$\\binom{\\left|T\\right|-2}{k-2}(-1)^{\\left|T\\right|-k-1+1}=\\binom{\\left|T\\right|-2}{k-2}(-1)^{\\left|T\\right|-k}$$ 所以当第$i$个原料在集合$T$中时，$dp_{i,j,k}$要加上$dp_{i-1,j-p_i,k-1}$，减去$dp_{i-1,j-p_i,k}$。 初始状态$dp_{i,0,0}=1$，即集合是空集，且求第$0$大，将$k=0$和$\\left|T\\right|=0$代入得出$dp_{i,0,0}=1$。 然而三个维度的$dp$转移空间会爆炸，所以把第一维滚掉，算完系数之后枚举$min(T)$乘上系数就行。 Code#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define ll long long const int MOD=998244353; int n,k,m,p[1050]; ll dp[10050][15],ans; ll ksm(ll a,ll b) { ll tmp=1; while(b) { if(b&amp;1)tmp=(1LL*tmp*a)%MOD; a=(1LL*a*a)%MOD; b&gt;&gt;=1; } return tmp; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m);k=n-k+1; dp[0][0]=1; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;p[i]); for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=p[i];j--) for(int u=1;u&lt;=k;u++) dp[j][u]=(dp[j][u]+dp[j-p[i]][u-1]-dp[j-p[i]][u]+MOD)%MOD; for(int i=1;i&lt;=m;i++)ans=(ans+1LL*dp[i][k]*ksm(i,MOD-2)%MOD*m%MOD)%MOD; printf(&quot;%lld&quot;,(ans+MOD)%MOD); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://tian-xing.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"min-max容斥","slug":"min-max容斥","permalink":"https://tian-xing.github.io/tags/min-max%E5%AE%B9%E6%96%A5/"}],"author":"Tian-Xing"},{"title":"计算几何","slug":"计算几何","date":"2020-01-19T07:38:26.000Z","updated":"2020-01-19T08:23:01.089Z","comments":true,"path":"2020/01/19/计算几何/","link":"","permalink":"https://tian-xing.github.io/2020/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/","excerpt":"向量在平面上交错生长织成 忧伤的网","text":"向量在平面上交错生长织成 忧伤的网 计算几何基础操作将向量$(x,y)$旋转$\\alpha$度设将向量$(x,y)$旋转$\\alpha$度后得到向量$(x’,y’)$，原向量的模长为$d$，极角为$\\theta$，则可得 $$d=\\sqrt{x^2+y^2}$$ $$sin(\\theta)=\\frac{y}{d}$$ $$cos(\\theta)=\\frac{x}{d}$$ $$sin(\\alpha+\\theta)=\\frac{y’}{d}$$ $$cos(\\alpha+\\theta)=\\frac{x’}{d}$$ 由三角函数的和角公式可以推出 $$sin(\\alpha+\\theta)=sin(\\alpha)cos(\\theta)+sin(\\theta)cos(\\alpha)$$ $$=sin(\\alpha)\\frac{x}{d}+cos(\\alpha)\\frac{y}{d}=\\frac{y’}{d}$$ $$cos(\\alpha+\\theta)=cos(\\alpha)cos(\\theta)-sin(\\theta)sin(\\alpha)$$ $$=cos(\\alpha)\\frac{x}{d}-sin(\\alpha)\\frac{y}{d}=\\frac{x’}{d}$$ 将分母中的$d$约去，则有 $$y’=sin(\\alpha)x+cos(\\alpha)y$$ $$x’=cos(\\alpha)x-sin(\\alpha)y$$","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://tian-xing.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"author":"Tian-Xing"},{"title":"组合数学","slug":"组合数学","date":"2020-01-18T01:05:14.000Z","updated":"2020-01-20T11:10:23.344Z","comments":true,"path":"2020/01/18/组合数学/","link":"","permalink":"https://tian-xing.github.io/2020/01/18/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","excerpt":"寒假的第一天在颓组合数学中度过","text":"寒假的第一天在颓组合数学中度过 组合数的性质$1.1$$$\\binom{n}{m} = \\binom{n}{n-m}$$ 考虑从$n$个物品里选$m$个物品的方案数和从$n$个物品里选$n-m$个物品扔掉的方案数是一样的。 $1.2$$$\\binom{n}{m} = \\binom{n-1}{m-1} + \\binom{n-1}{m}$$ 考虑从$n$个物品里选$m$个物品的方案数有两种情况转移过来，一种是当前物品不选，那么就是从剩下的$n-1$个物品里选$m$个物品，另一种是选择当前物品，那么就是从剩下的$n-1$种物品里选择$m-1$个物品。 $1.3$$$\\sum_{i=0}^n \\binom{m+i}{i} = \\binom{m+n+1}{n}$$ 根据$1.2$，有$\\binom{m}{0} = \\binom{m+1}{0}$，所以原式变为 $$\\binom{m+1}{0} + \\binom{m+1}{1} + \\binom{m+2}{2} + \\cdots + \\binom{m+n}{n}$$ $$\\binom{m+2}{1} + \\binom{m+2}{2} + \\cdots + \\binom{m+n}{n}$$ 以此类推，将它们两两合并，最后结果就是$\\binom{m+n+1}{n}$。 $1.4$$$\\sum_{i=0}^n \\binom{n}{i} = 2^n$$ 根据二项式定理，有 $$(1+1)^n = \\sum_{i=0}^n \\binom{n}{i} 1^i 1^{n-i}$$ $$(1+1)^n = \\sum_{i=0}^n \\binom{n}{i}$$ $$2^n = \\sum_{i=0}^n \\binom{n}{i}$$ $1.5$$$\\sum_{i=0}^n \\binom{n}{i} x^i = (x+1)^n$$ 这也是从二项式定理搞过来的 $$(x+1)^n = \\sum_{i=0}^n \\binom{n}{i} x^i 1^{n-i}$$ $$(x+1)^n = \\sum_{i=0}^n \\binom{n}{i} x^i$$ $1.6$$$\\sum_{i=0}^n (-1)^i \\binom{n}{i} = 0$$ 其实就是$1.5$的变形，当$x=-1$的时候。 $1.7$$$\\binom{n}{m} \\times \\binom{m}{r} = \\binom{n}{r} \\times \\binom{n-r}{m-r}$$ 根据定义式将式子展开，可得 $$\\frac{n!}{m! \\times (n-m)!} \\times \\frac{m!}{r! \\times (m-r)!}$$ 约去$m!$，同时乘$(n-r)!$，再把$(n-m)!$和$r!$交换位置，可得 $$\\frac{n!}{(n-r)! \\times r!} \\times \\frac{(n-r)!}{(n-m)! \\times (m-r)!}$$ 也就是 $$\\binom{n}{r} \\times \\binom{n-r}{m-r}$$ 我们还可以考虑按定义推导，原式计数的是从$n$个元素中选$m$个元素，再从$m$个元素中选$r$个元素的数量，那么我们可以先选出$r$个元素，再考虑有多少个集合包含了它，也就是从剩下的$n-r$个元素中再选$m-r$个。 $1.8$$$\\sum_{i=0}^{n/2} \\binom{n}{2i} = \\sum_{i=0}^{n/2} \\binom{n}{2i+1} = 2^{n-1}$$ 根据$1.6$，有 $$\\sum_{i=0}^{n/2} \\binom{n}{2i} = \\sum_{i=0}^{n/2} \\binom{n}{2i+1}$$ 根据$1.4$，有 $$\\sum_{i=0}^{n/2} \\binom{n}{2i} + \\sum_{i=0}^{n/2} \\binom{n}{2i+1} = 2^n$$ 所以，有 $$\\sum_{i=0}^{n/2} \\binom{n}{2i} = \\sum_{i=0}^{n/2} \\binom{n}{2i+1} = 2^n \\div 2=2^{n-1}$$ $1.9$$$\\binom{n+m}{r} = \\sum_{i=0}^r \\binom{n}{i} \\times \\binom{m}{r-i}$$ 根据组合数的定义，在$n+m$个数中选$r$个的方案数等于枚举在$n$个元素中选几个，剩下的在$m$个元素中选。 特别的，当$n=m=r$时，有 $$\\binom{2n}{n} = \\sum_{i=0}^n \\binom{n}{i} \\binom{n}{n-i} = \\sum_{i=0}^n\\binom{n}{i} \\times \\sum_{i=0}^n \\binom{n}{i} =\\sum_{i=0}^n \\binom{n}{i}^2$$ $1.10$$$m \\times \\binom{n}{m} = n \\times \\binom{n-1}{m-1}$$ 根据定义式将式子拆开，有 $$m \\times \\frac{n!}{m! \\times (n-m)!}$$ 将$m$和分母中的$m!$约分，再将分子里的$n!$中拆一个$n$出来，得到 $$n \\times \\frac{(n-1)!}{(m-1)! \\times (n-m)!}$$ $1.11$$$\\sum_{i=1}^n \\binom{n}{i} \\times i = n \\times 2^{n-1}$$ 还是按照定义式展开，并将$i$乘进去，可得 $$n \\sum_{i=1}^n \\frac{(n-1)!}{(i-1)! \\times (n-i)!}$$ 也就是 $$n \\sum_{i=1}^n \\binom{n-1}{i-1}$$ 用$i-1$代替$i$,得 $$n \\sum_{i=0}^{n-1} \\binom{n-1}{i}$$ 也就是 $$n \\times 2^{n-1}$$ $1.12$$$\\sum_{i=1}^n \\binom{n}{i} \\times i^2 = n \\times (n+1) \\times 2^{n-2}$$ 也同样按定义式拆开，将$i$乘进去，得到 $$n \\sum_{i=0}^{n-1} \\binom{n-1}{i} \\times (i+1)$$ $$= n \\sum_{i=0}^{n-1} \\binom{n-1}{i} + n \\sum_{i=0}^{n-1} \\binom{n-1}{i} \\times i$$ $$= n \\times 2^{n-1} + n \\times (n-1) \\times 2^{n-2}$$ $$= n \\times 2^{n-2} \\times (n+2-1)$$ $$= n \\times (n+1) \\times 2^{n-2}$$ $1.13$$$\\sum_{i=k}^n \\binom{i}{k} = \\binom{n+1}{k+1}$$ 把$1.2$式带进去就好了。 广义莫比乌斯反演经典莫比乌斯反演$\\phi \\ast 1=id$ 的证明 $$\\phi(p^k)\\ast1$$ $$=\\sum_{d|p^k}\\phi(d)$$ $$=\\sum_{i=0}^k\\phi(p^i)$$ $$=\\sum_{i=0}^k(p^i-p^{i-1})$$ $$=p^k$$ $$Q.E.D.$$ 由于$\\phi \\ast 1$是积性函数，所以$\\phi \\ast 1(n)=\\prod_{i=1}^k\\phi \\ast 1(pi)=\\prod_{i=1}^kpi=id$,所以$\\phi \\ast 1=id$ 子集反演对于两个函数$F(S)$和$G(S)$ $$F(S)=\\sum_{T\\subseteq S}G(T)$$ 那么我们可以得出 $$G(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}F(T)$$ $$G(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}F(T)$$ $$=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}\\sum_{U\\subseteq T}G(U)$$ $$=\\sum_{U\\subseteq S}G(U)\\sum_{U\\subseteq T \\subseteq S}(-1)^{|S|-|T|}$$ 通过枚举$|T|-|U|$的元素个数即 $$|T|=|U|+i$$ $$=\\sum_{U\\subseteq S}G(U)\\sum_{i=0}^{|S|-|U|}\\binom{|S|-|U|}{i}(-1)^{|S|-|U|-i}$$ 然后喜闻乐见的发现了一个二项式定理 $$=\\sum_{U\\subseteq S}G(U)0^{|S|-|U|}$$ 当$|S|=|U|$时,带进原式我们惊奇的发现后面这玩意 $$=(-1)^{|S|-|U|}=1$$ $$=\\sum_{U\\subseteq S}G(U)[U=S]$$ $$=G(S)$$ $$Q.E.D.$$ 杜教筛杜教筛的离散化：因为每一次传进去的参数如果$&lt;\\sqrt n$，就直接调用预处理出来的数据，如果$&gt;\\sqrt n$就进行记忆化，因为都$&gt; \\sqrt n$，而且每个数都可以被表示成$n/x$的形式，那么对于每个n都有不同的x那么就可以把这个存进不同的x里面，开一个$\\sqrt n$的数组就行。 但是如果n变化了显然$n/x$就不一样了，那么就要全部清空 如果有两个参数$n$和$m$,那么也不能这样离散化，因为每次对于$n/i$相等的一段区间可能会进行多次杜教筛计算，同一段表示成$n/x$中的x都是相同的，这样同一段都会被存进同一个$x$里面，这样就会产生冲突 $min-max$容斥设$max(S)$表示集合$S$中的最大值，$min(S)$表示集合$S$中的最小值，那么可以这样反演 $$max(S) = \\sum_{T \\subseteq S} (-1)^{\\left| T \\right| -1} min(T)$$ $$min(S) = \\sum_{T \\subseteq S} (-1)^{\\left| T \\right| -1} max(T)$$ 由于求$min$和求$max$类似，所以以下只对求$max$进行讨论。 考虑设$f(\\left| T \\right|)$为反演系数，针对集合中所有元素中第$x+1$大的元素，用$num(x+1)$表示其出现次数，考虑该元素在多少个集合里产生了贡献，有 $$num(k+1) = \\sum_{i=0}^k \\binom{k}{i} \\times f(k+1)$$ 二项式反演，得 $$num(k+1) = \\sum_{i=0}^k \\binom{k}{i} \\times f(k+1)$$ 当要求集合中最大的元素时,只有最大值的元素出现次数为$1$，其它元素出现次数都为$0$,所以有 $$[k==0] = \\sum_{i=0}^k \\binom{k}{i} \\times f(k+1)$$ 二项式反演，得 $$f(k+1) = \\sum_{i=0}^k (-1)^{k-i} \\binom{k}{i} \\times [i==0]$$ 所以对于一个大小为$x$的集合来说,其反演系数为 $$f(k)=(-1)^{k-1}$$ 如果我们仔细观察一下推导过程，就会发现我们不仅能求最大和最小值，还能求第$x$大值。 转到对容斥系数的证明 $$num(k+1) = \\sum_{i=0}^k \\binom{k}{i} \\times f(k+1)$$ 当求第$x$大值的时候，只有$num(x)$为$1$，其它都为$0$,所以有 $$[k==x-1] = \\sum_{i=0}^k \\binom{k}{i} \\times f(k+1)$$ 二项式反演，有 $$f(k+1) = \\sum_{i=0}^k (-1)^{k-i} \\binom{k}{i} \\times [i==x-1]$$ $$f(k) = (-1)^{k-x} \\times \\binom{k-1}{x-1}$$ 所以得到求第$x$大的$min-max$容斥式子 $$kthmax(S) = \\sum_{T \\subseteq S} (-1)^{\\left| T \\right| -x} \\times \\binom{\\left| T \\right| -1}{x-1} min(T)$$","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://tian-xing.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"author":"Tian-Xing"},{"title":"洛谷P2435 染色","slug":"洛谷P2435 染色","date":"2019-12-15T11:53:45.000Z","updated":"2019-12-29T03:56:29.151Z","comments":true,"path":"2019/12/15/洛谷P2435 染色/","link":"","permalink":"https://tian-xing.github.io/2019/12/15/%E6%B4%9B%E8%B0%B7P2435%20%E6%9F%93%E8%89%B2/","excerpt":"学了好久忘光了，来补一发轮廓线DP","text":"学了好久忘光了，来补一发轮廓线DP 这道题有很显然的状压做法，然而直接状压是会$T$飞的，最多只能拿到$80PTS$ 所以这时我们要引出一个新的状压技巧—轮廓线状压 所谓轮廓线状压，顾名思义就是状压一条线 如下图所示，假设我们要更新绿色格点对答案的影响，我们之前状压的就是红色的这条线，接下来我们根据题目的具体规则进行刷表转移，枚举这个绿色格点的所有可能取值，然后更新到蓝色格点即可需要注意的是每个格点只能更新到与他相邻的下一个格点，那么我们每次只能向一个状态更新，再算上这次使用的状态一共就是两个状态，所以这里可以用滚动数组优化掉一维$DP$状态 具体的对于这个题而言我们枚举当前格点的颜色如果和它相邻的格点和它颜色不一样那么就可以把它的影响加入答案并且更新到下一个格点的状态 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; #define re register #define ll long long const ll MOD=376544743; int n,m,k,head,tail; int answer,dp[2][50000050]; int mi[15]; int read() { int s=0,p=1; char st=getchar(); while(st&lt;&#39;0&#39; || st&gt;&#39;9&#39;) { if(st==&#39;-&#39;)p=-1; st=getchar(); } while(st&gt;=&#39;0&#39; &amp;&amp; st&lt;=&#39;9&#39;) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+(st^48); st=getchar(); } return s*p; } int find(int x,int j) { return (x/mi[j-1])%k; } int change(int x,int j,int y) { return x-find(x,j)*mi[j-1]+y*mi[j-1]; } void print(int x) { for(int i=1;i&lt;=m;i++)cout&lt;&lt;x%k,x/=k; } int ch(int a) { int last,now; last=a%k; a=a/k; for(int i=1;i&lt;=m-1;i++) { now=a%k; if(last==now)return 0; last=now; a=a/k; } return 1; } int main() { n=read();m=read();k=read(); int x; for(int i=1;i&lt;=m;i++)x=read(),head=(head*k)+x; for(int i=1;i&lt;=m;i++)x=read(),tail=(tail*k)+x; if(k==2) { if(n%2==0) { if(head==tail)cout&lt;&lt;0; else cout&lt;&lt;1; } else { if(head==tail)cout&lt;&lt;1; else cout&lt;&lt;0; } return 0; } mi[0]=1; for(int i=1;i&lt;=m;i++)mi[i]=mi[i-1]*k; dp[1][head]=1; int r=0; int all=mi[m]; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { r=r^1; for(int d=0;d&lt;all;d++)dp[r^1][d]=0; for(int d=0;d&lt;all;d++) { if(dp[r][d]==0)continue; int lll; int rr=find(d,j); lll=-1; if(j-1&gt;0)lll=find(d,j-1); for(int p=0;p&lt;=k-1;p++)if(p!=lll &amp;&amp; p!=rr)(dp[r^1][change(d,j,p)]+=dp[r][d])%=MOD; } } printf(&quot;%d&quot;,dp[r^1][tail]%MOD); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://tian-xing.github.io/tags/DP/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://tian-xing.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}],"author":"Tian-Xing"},{"title":"AtCoder2062 ~K Perm Counting","slug":"AtCoder2062 ~K Perm Counting","date":"2019-12-15T11:50:56.000Z","updated":"2019-12-29T03:55:42.973Z","comments":true,"path":"2019/12/15/AtCoder2062 ~K Perm Counting/","link":"","permalink":"https://tian-xing.github.io/2019/12/15/AtCoder2062%20~K%20Perm%20Counting/","excerpt":"思路很是巧妙呢","text":"思路很是巧妙呢 最开始不难想到这题应该是用容斥去做 设$g[i]$表示至少$i$个位置是冲突的方案数 那么答案就是$$\\sum_{i=0}^n(-1)^i g[i] (n-i)!$$首先可以发现一个显然的性质，每个排列里的点最多只有两个点和它冲突(根据绝对值的性质 那么一个很妙的方法就是我们把和一个点冲突的点连边 这样就形成了一张图，这张图有一些很妙的性质 首先这是一张二分图，它的两个子集里都有$n$个节点 我们尝试画出这个二分图 以样例”3 1”为例 $(A_1,B_2)$$(A_2,B_1)$$(A_2,B_3)$$(A_3,B_2)$ 我们发现这张二分图里的一些边连接在一起就形成了一些链，现在我们把这些链提出来 下面这个样子 $A_1-&gt;B_2-&gt;A_3$$B_1-&gt;A_2-&gt;B_3$ 接着很显然可以看出这些链是互不影响的且每条链上只能选择一条边 那么我们可以对图进行重构,将它按$\\mod k$的余数重新排列(因为只在$\\mod k$相同的情况下存在连边 这样的话记录边就只用记录这个点和上个点有没有连边就行 接着开始$dp$ 重构图之后一共有$n*2$个点 设$dp[i][j][0]$表示前$i$个点,选择了$j$条边,$i$和$i-1$有连边的方案数 $dp[i][j][1]$表示前$i$个点,选择了$j$条边,$i$和$i-1$没有连边的方案数 接着可以推出$dp$式子 $dp[i][j][0]=dp[i-1][j-1][0]+dp[i-1][j-1][1]$$dp[i][j][1]=dp[i-1][j-1][0]$ 如果$i$和$i-1$有连边 注意不能选择相邻的两条边因为同一个位置只能有一个数值 那么$g[i]=dp[n*2][i][0]+dp[n*2][i][1]$ 最后容斥即可 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define MOD 924844033 #define ll long long #define N 2050 ll dp[N&lt;&lt;1][N][2],n,k,link[2*N],tot,sum,jc[N]; int main() { scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); jc[0]=1;dp[0][0][0]=1; for(int i=1;i&lt;=n;i++)jc[i]=jc[i-1]*i%MOD; for(int i=1;i&lt;=k;i++) for(int t=1;t&lt;=2;t++) for(int j=i;j&lt;=n;j+=k) j!=i?link[++tot]=1:++tot; for(int i=1;i&lt;=tot;i++) for(int j=0;j&lt;=n;j++) { dp[i][j][0]=(dp[i-1][j][1]+dp[i-1][j][0])%MOD; if(link[i])dp[i][j][1]=dp[i-1][j-1][0]; } for(int i=0;i&lt;=n;i++) { ll tmp=(dp[n&lt;&lt;1][i][0]+dp[n&lt;&lt;1][i][1])%MOD; tmp=tmp*jc[n-i]%MOD; i%2==1?sum=((sum-tmp)%MOD+MOD)%MOD:sum=(sum+tmp)%MOD; } printf(&quot;%lld&quot;,sum); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://tian-xing.github.io/tags/DP/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://tian-xing.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"}],"author":"Tian-Xing"},{"title":"HAOI2008 硬币购物","slug":"HAOI2008 硬币购物","date":"2019-12-08T00:59:35.000Z","updated":"2019-12-29T03:48:17.742Z","comments":true,"path":"2019/12/08/HAOI2008 硬币购物/","link":"","permalink":"https://tian-xing.github.io/2019/12/08/HAOI2008%20%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/","excerpt":"很经典的一道容斥题","text":"很经典的一道容斥题 先来看一个很经典的问题 $$ \\sum_{i=1}^n x_i=s(x是正整数)$$ 这个式子的$x$的解有多少个? 显然这个可以用背包计算 用$dp[k]$表示能表示出的和为$k$的解的数量，正序枚举$k$ $$ dp[k]=dp[k]+dp[k-money[i]] $$ 其中$money[i]$是硬币的面值 接下来我们给他加上限制，规定第$i$个$x$的上界是$c[i]$ 现在的$x$的解的总数可以用容斥原理进行计算 我们要求的东西是 $$ \\left | \\bigcap a_i\\right | (a_i为第i个元素满足限制下的解集的集合)$$ 也就等于 $$ \\left | S \\right |-\\left | \\bigcup {\\overline a_i} \\right |$$ 首先我们计算出所有的可能的情况也就是全集$s$ 接下来我们把不合法的情况减去 根据容斥定理显然有答案=总的情况$-1$个不满足条件的$+2$个不满足条件的$-3$个不满足条件的…… 那么如果能很快的求出几个不合法集合的并集的话，这道题就可以很轻松的解决了 考虑几个不合法集合的并集也是一个等式的形式，不过有的x有下界，有的x没有下界 那么显然下界那部分对于每一个解都是存在的 那么我们可以把它减去 也就是这样的 $$\\sum x_i=s-所有下界的和$$ 这个玩意的所有解的数量我们已经用$dp$处理出来了，直接调用即可 所以最后只需要枚举子集，然后观察一下子集中元素的个数，套上一个容斥系数即可 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define ll long long ll mz[5],dp[2000050],c[5]; ll ans,s; int main() { for(int i=1;i&lt;=4;i++)scanf(&quot;%d&quot;,&amp;mz[i]); dp[0]=1; for(int i=1;i&lt;=4;i++) for(int k=mz[i];k&lt;=100000;k++) dp[k]+=dp[k-mz[i]]; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { for(int i=1;i&lt;=4;i++)scanf(&quot;%d&quot;,&amp;c[i]); scanf(&quot;%lld&quot;,&amp;s); ans=dp[s]; for(int i=1;i&lt;(1&lt;&lt;4);i++) { ll tmp=0,js=0; for(int j=1;j&lt;=4;j++)if(1&lt;&lt;(j-1)&amp;i)js++,tmp+=(c[j]+1)*mz[j]; if(tmp&gt;s)continue; if(js%2==0)ans+=dp[s-tmp]; else ans-=dp[s-tmp]; } printf(&quot;%lld\\n&quot;,ans); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://tian-xing.github.io/tags/DP/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://tian-xing.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"}],"author":"Tian-Xing"},{"title":"HAOI2008 圆上的整点","slug":"HAOI2008 圆上的整点","date":"2019-11-07T23:45:13.000Z","updated":"2019-12-29T03:46:46.381Z","comments":true,"path":"2019/11/08/HAOI2008 圆上的整点/","link":"","permalink":"https://tian-xing.github.io/2019/11/08/HAOI2008%20%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9/","excerpt":"早上没有干劲来颓blog，结果被教练抓去打比赛，一直咕到下午","text":"早上没有干劲来颓blog，结果被教练抓去打比赛，一直咕到下午 假设我们已经求得$x^2+y^2=r^2$的所有正整数解$ans$ 那么我们很容易就可以发现每个象限都有到原点距离等于正整数解的这么多点 再算上坐标轴上一定会存在的4个点,那么答案就是$ans*4+4$ 现在考虑如何快速求出$x^2+y^2=r^2$的所有正整数解 这时我们引入勾股方程的概念 勾股方程即形如$a^2+b^2=c^2$的方程 本题中已知$c^2$的值 一个事实是勾股方程的所有正整数解都可以被表示为下图的形式 $$1.1:a=\\frac{d(u^2-v^2)}{2},b=duv,c=\\frac{d(u^2+v^2)}{2}(gcd(u,v)=1)$$ 也就是说每个勾股数组都可以由下面的式子同时乘一个数变换过来 $$1.2:a=\\frac{u^2-v^2}{2},b=uv,c=\\frac{u^2+v^2}{2}(gcd(u,v)=1)$$ 这是为什么呢，考虑所有的勾股方程的整数解都是一个勾股数组，那么肯定可以被表示成如下的形式 $$1.3:a=u^2-v^2,b=4uv,c=u^2+v^2$$ 所以假如式子$1.2$中的$a,b,c$的$gcd=1$，那么我们就可以用它不重不漏的表示出所有的勾股数组 证明左转洛谷日报-勾股数组 既然$1.1$可以不重不漏的表示出所有的解，那么我们就可以枚举$d$求出答案 具体步骤如下： 首先枚举$d\\mid2r$,那么$u^2+v^2=2r/d$接下来枚举$u$,验证$u$是否合法(如果存在$u^2+v^2=2r/d$并且$gcd(u,v)=1$则合法)，如果合法答案加一 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; #define ll long long ll ans=0,r; ll gcd(ll a,ll b) { return !b?a:gcd(b,a%b); } bool check(ll u,ll V) { int v=(ll)(sqrt(V)); if(V==v*v)return gcd(u,v)==1; return 0; } ll calc(ll x) { ll tmp=0; for(ll u=1;u*u*2&lt;x;u++) tmp+=check(u,x-u*u); return tmp; } int main() { scanf(&quot;%lld&quot;,&amp;r); for(ll d=1;d*d&lt;=2*r;d++) if(2*r%d==0) ans+=calc(2*r/d)+(d*d==2*r?0:calc(d)); printf(&quot;%lld\\n&quot;,ans*4+4); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://tian-xing.github.io/tags/%E6%95%B0%E8%AE%BA/"}],"author":"Tian-Xing"},{"title":"DP优化","slug":"DP优化","date":"2019-10-30T07:08:42.000Z","updated":"2020-01-15T23:47:19.519Z","comments":true,"path":"2019/10/30/DP优化/","link":"","permalink":"https://tian-xing.github.io/2019/10/30/DP%E4%BC%98%E5%8C%96/","excerpt":"dp真是好玩，有好多有趣且优美的优化。","text":"dp真是好玩，有好多有趣且优美的优化。 四边形不等式优化首先，什么是四边形不等式？一句话来概括，就是：相交小于包含一维二维的满足四边形不等式的dp式子都具有决策单调性，都可以被优化二维的太复杂了,我只写一维的好了令$w(x,y)$是定义在整数集合上的二元函数，对于$a&lt;=b&lt;=c&lt;=d$,有$w(a,c)+w(b,d)&lt;=w(a,d)+w(b,c)$，则称此函数满足四边形不等式。但是在dp的时候，这种式子不常出现，对于两个确定的i和j，如何确定该函数满足四边形不等式呢？有如下的定理:对于$a&lt;b$，有$w(a,b+1)+w(a+1,b)&gt;=w(a+1,b+1)+w(a,b)$成立，则此函数满足四边形不等式。证明如下： 对于$a&lt;c$,有$w(a,c+1)+w(a+1,c)&gt;=w(a,c)+w(a+1,c+1)$对于$a+1&lt;c$，有$w(a+1,c+1)+w(a+2,c)&gt;=w(a+1,c)+w(a+2,c+1)$两式相加，得到$w(a,c+1)+w(a+2,c)&gt;=w(a,c)+w(a+2,c+1)$以此类推，对任意的$a&lt;=b&lt;=c$，有$w(a,c+1)+w(b,c)&gt;=w(a,c)+w(b,c+1)$同理，对于任意的$a&lt;=b&lt;=c&lt;=d$,有$w(a,d)+w(b,c)&gt;=w(a,c)+w(b,d)$$Q.E.D.$ 那么，四边形不等式如何优化dp呢？对于一维的dp，我们可以将形如$dp[i]=min_{i=0}^j(dp[j]+w(i,j))$的式子优化，因为它具有决策单调性，于是我们用一个单调队列来维护每个i的最优更新的j，就可以在$O(nlogn)$的复杂度内求解问题。 我们来看一下为什么具有决策单调性 令$p[i]$表示对于点$i$的最优决策点那么任选$0&lt;=j&lt;i$，$j$更新$i$一定比$p[i]$更新$i$更劣所以得到式子1:$dp[p[i]]+w(p[i],i)&lt;=dp[j]+w(j,i)$接着我们任选$i+1&lt;=q&lt;+n$，因为函数$w$满足四边形不等式，所以我们得到式子2:$w(j,q)+w(p[i],i)&gt;=w(p[i],q)+w(j,i)$对式子2移项，得:$w(p[i],q)-w(p[i],i)&lt;=w(j,q)-w(j,i)$与式子1相加，得:$dp[p[i]]+w(p[i],q)&lt;=dp[j]+w(j,q)$也就是说，以$p[i]$为决策点来转移$q$比以$j$为决策点转移$q$更优所以对于$p[i]$之前的所有决策点都不如$p[i]$来转移$i$之后的点更优，即决策单调性$Q.E.D$ 那么我们怎么来维护这些决策点呢？用一个单调队列维护即可,单调队列里面用结构体存储决策点存储决策点的位置,决策点可以优化的点的区间的左端点，右端点。每次加入一个新的决策点的时候若新加的决策点比一整个决策点可以优化的区间都优秀，就直接将这个决策点出队如果比这个决策点可以优化的区间都劣，就将当前的决策点扔到单调队列的队尾否则在这个决策点的可优化区间里二分一个点，使得这个点之前都是这个决策点优化更优，这个点之后都是新加进去的决策点更优，改变队尾结构体里记录的值，将当前的决策点入队即可。 NOI2009诗人小G 题目描述小G是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。 一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小G给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小G不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小G对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的P次方，而一个排版的不协调度为所有行不协调度的总和。 小G最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。 输入格式输入文件中的第一行为一个整数T，表示诗的数量。 接下来为T首诗，这里一首诗即为一组测试数据。每组测试数据中的第一行为三个由空格分隔的正整数N，L，P，其中：N表示这首诗句子的数目，L表示这首诗的行标准长度，P的含义见问题描述。 从第二行开始，每行为一个句子，句子由英文字母、数字、标点符号等符号组成（ASCII码33～127，但不包含’-‘）。 输出格式于每组测试数据，若最小的不协调度不超过10^18，则第一行为一个数，表示不协调度。接下来若干行，表示你排版之后的诗。注意：在同一行的相邻两个句子之间需要用一个空格分开。 如果有多个可行解，它们的不协调度都是最小值，则输出任意一个解均可。若最小的不协调度超过10^18，则输出“Too hard to arrange”（不含引号）。每组测试数据结束后输出“——————–”（不含引号），共20个“-”，“-”的ASCII码为45，请勿输出多余的空行或者空格。 显然令dp[i]表示前i句诗的最小不协调值，sum[i]为前i句诗的前缀和长度有状态转移方程:$dp[i]=min_{i=0}^jabs(sum[i]-sum[j]+i-j-1-L)^p$我们如果证明这个式子可以用四边形不等式优化，就可以O(nlogn)求出答案设$w(i,j)=abs(sum[i]-sum[j]+i-j-1-L)^p$那么如果$w(a,b+1)+w(a+1,b)&gt;=w(a+1,b+1)+w(a,b)$，就可以说明它满足四边形不等式那么只需证明$w(a+1,b)-w(a+1,b+1)&gt;=w(a,b)-w(a,b+1)$即可令$b1=sum[b]+b-sum[a]-a-l-1,b2=sum[b]+b-sum[a]-a-1-l-1$只需证明$abs(b2)^p-abs(b2+(a[i+1]+1))^p&gt;=abs(b1)^p-abs(b1+(a[i+1]+1))^p$即可易得，$b2&gt;b1$,那么只需证明对于任意的常数c,函数$y=abs(x)^p-abs(x+c)^p$单调递减我太菜了不会证明emmmm，引用算法竞赛进阶指南 当p为奇数，x为负数原函数为y=-x^p-(x+c)^p，求导，发现y’&lt;=0，所以单调递减其他情况大力分类讨论 CODE#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define ll long long const double eps=1e-8; long double ksm(long double a,ll b) { long double tmp=1; while(b) { if(b&amp;1)tmp=tmp*a; a=a*a; b&gt;&gt;=1; } return tmp; } int n,head,tail,ans[200050]; string stt[200050]; ll sum[200050],p,l; long double f[200050]; struct node { int j,l,r; }q[5000050]; long double abss(ll x) { return x&lt;0?-x:x; } long double zhi(int j,int i) { return ksm(abss((sum[i]-sum[j])+(i-j-1)-l),p); } void print(int n) { if(!n)return; int t=ans[n];print(t); for(int i=t+1;i&lt;=n;i++) { cout&lt;&lt;stt[i]; if(i!=n)putchar(&#39; &#39;); } printf(&quot;\\n&quot;); } int query(int l,int r,int i,int j) { int mid;++r; while(l&lt;r) { mid=(l+r)&gt;&gt;1; if(f[j]+zhi(j,mid)&gt;f[i]+zhi(i,mid))l=mid+1; else r=mid; } return l; } int main() { int kkk; scanf(&quot;%d&quot;,&amp;kkk); while(kkk--) { memset(ans,0,sizeof(ans)); head=1;tail=0; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;l,&amp;p); for(int i=1;i&lt;=n;i++)cin&gt;&gt;stt[i],sum[i]=sum[i-1]+stt[i].size(); f[0]=0; for(int i=1;i&lt;=n;i++) { while(head&lt;=tail &amp;&amp; f[i-1]+zhi(i-1,q[tail].l)&lt;=f[q[tail].j]+zhi(q[tail].j,q[tail].l))tail--; if(head&lt;=tail) { int pos=query(q[tail].l,q[tail].r,q[tail].j,i-1); if(pos&lt;=n)q[tail].r=pos-1,q[++tail]=(node){i-1,pos,n}; } else q[++tail]=(node){i-1,i,n}; while(head&lt;=tail &amp;&amp; q[head].r&lt;i)++head; if(head&lt;=tail)q[head].l=i; int pos=q[head].j; f[i]=f[pos]+zhi(pos,i),ans[i]=pos; } if(f[n]-1e18&gt;eps)printf(&quot;Too hard to arrange\\n&quot;); else { printf(&quot;%lld\\n&quot;,(ll)(f[n])); print(n); } printf(&quot;--------------------&quot;); if(kkk)printf(&quot;\\n&quot;); } return 0; }","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://tian-xing.github.io/tags/DP/"}],"author":"Tian-Xing"},{"title":"IOI2008 Island","slug":"IOI2008 Island","date":"2019-10-24T22:56:16.000Z","updated":"2019-12-29T06:19:52.904Z","comments":true,"path":"2019/10/25/IOI2008 Island/","link":"","permalink":"https://tian-xing.github.io/2019/10/25/IOI2008%20Island/","excerpt":"算是较难的一道基环树模板题","text":"算是较难的一道基环树模板题 题意简明扼要，有一堆基环树构成了基环树森林，需求所有基环树的直径之和。 基环树定义：一棵树有$n$个节点$n$条边 显然一棵普通的树有$n$个节点$n-1$条边，那么基环树就是在普通的树的基础上多加了一条边，这条边必然会形成一个环。 所以基环树相对于树来讲就是多了一个环的处理。 基环树的直径求法： 首先肯定要找到环上的所有节点，就是相当于无向图找环。大致上常用的有拓扑排序和$dfs$，$tarjan$也可以。(我使用了$dfs$找环 $dfs$在无向图上找环比较麻烦，它只能处理环的变数$&gt;2$的环，所以$=2$的环还要进行特判。（大体来说就是$num$从$1$开始建边这样一条边的反向边就是$i\\oplus1$,这样特判一下就好了。 找到环后，通过对一些例子的手玩，不难发现基环树直径的构成情况： $1.$就是不在环上的节点组成的最长链。$2.$由环上两点及分别以他们为根的子树中的经过根的最长链构成。 对第一种情况我们开一个数组记录哪些点在环上，对环上每个点分别跑一遍最长链的$dp$并同时更新$answer$即可。如果他的儿子在环上就$continue$。跑完之后再开一个数组记录经过根的最长链。 (最长链$dp$就是对每个节点求出以他为根的子树且经过他的最长链和次长链，每求完一个节点的信息就对$answer$进行更新。 对于环上的两点之间的距离，可能是顺时针也可能是逆时针。所以需要破环成链，这样每个节点都会被逆时针顺时针走一遍。求出一个距离前缀数组，两点之间差值即为环上距离。 那么现在可以写出$dp$式子$answer=max(answer,d[i]+d[j]+dis[i]-dis[j])$ 这个$dp$式子的与i有关和与j有关的项是独立的，所以可以单调队列优化。 对于每个节点找到他之前的$d[j]-dis[j]$最大的$j$更新即可 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define ll long long #define int long long #define N 1000050 int head[N],num=1,n,vis[N],ins[N],stack[N],top,circle[N],cnt,flag,zongshu,huan[N],q[N*2],ooo,tmp; ll ans,answer,dis[N*2],dp[N][2],d[N*2]; struct node { int next,to; ll dis; }edge[N*2]; void addedge(int u,int v,ll w) { edge[++num]=(node){head[u],v,w}; head[u]=num; } void dfs(int x,int fa) { ins[x]=1,stack[++top]=x; for(register int i=head[x];i;i=edge[i].next) { if(flag)return; int v=edge[i].to; if(v==fa)continue; if(ins[v]) { flag=1;circle[++cnt]=v;huan[v]=1; while(stack[top]!=v) huan[stack[top]]=1,circle[++cnt]=stack[top--]; return; } dfs(v,x); } top--;ins[x]=0; } void dfs2(int x,int fa) { if(!vis[x])zongshu++,vis[x]=1; for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(v==fa)continue; if(!vis[v])dfs2(v,x); } } void dpp(int x,int fa) { for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(v==fa || huan[v])continue; dpp(v,x); if(dp[v][0]+edge[i].dis&gt;dp[x][0]) { dp[x][1]=dp[x][0]; dp[x][0]=dp[v][0]+edge[i].dis; } else if(dp[v][0]+edge[i].dis&gt;dp[x][1]) { dp[x][1]=dp[v][0]+edge[i].dis; } } answer=max((ll)dp[x][0]+dp[x][1],answer); } void dfs3(int x,ll uuu) { dis[++ooo]=uuu; for(int i=head[x];i;i=edge[i].next) { if(ooo==2*cnt)return; int v=edge[i].to; if(v!=q[ooo+1])continue; dfs3(v,uuu+edge[i].dis); } } void find2(int x,int fa,int last) { for(int i=head[x];i;i=edge[i].next) { if(flag)return; int v=edge[i].to; if(v==fa &amp;&amp; i!=last &amp;&amp; i!=(last^1)) { circle[++cnt]=x; circle[++cnt]=fa; huan[x]=huan[fa]=1;flag=1; tmp=max(edge[i].dis,edge[last].dis); } else if(v!=fa)find2(v,x,i); } } ll solve(int root) { zongshu=0; dfs2(root,0); if(zongshu==2) { answer=0; for(int i=head[root];i;i=edge[i].next)answer=max(answer,edge[i].dis); return answer; } for(int i=1;i&lt;=n;i++)stack[i]=0,ins[i]=0; flag=top=cnt=answer=0; dfs(root,0); if(cnt==0) { flag=0; tmp=0; find2(root,0,-1); for(int i=1;i&lt;=cnt;i++)dpp(circle[i],0),d[circle[i]]=dp[circle[i]][0]; answer=max(answer,tmp+d[circle[1]]+d[circle[2]]); return answer; } ooo=0; for(int i=1;i&lt;=cnt;i++)dpp(circle[i],0),d[circle[i]]=dp[circle[i]][0]; for(int i=1;i&lt;=cnt;i++)q[i]=circle[i],q[i+cnt]=circle[i],circle[i+cnt]=circle[i]; dfs3(q[1],0); int head=0,tail=1; q[++head]=1; for(int i=2;i&lt;=2*cnt;i++) { while(head&lt;=tail &amp;&amp; q[head]&lt;=i-cnt)head++; answer=max(answer,d[circle[i]]+d[circle[q[head]]]+dis[i]-dis[q[head]]); while(head&lt;=tail &amp;&amp; d[circle[i]]-dis[i]&gt;=d[circle[q[tail]]]-dis[q[tail]])tail--;q[++tail]=i; } return answer; } signed main() { freopen(&quot;random.out&quot;,&quot;r&quot;,stdin); freopen(&quot;myanswer.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld&quot;,&amp;n); int u;ll v; for(int i=1;i&lt;=n;i++)scanf(&quot;%lld%lld&quot;,&amp;u,&amp;v),addedge(i,u,v),addedge(u,i,v); for(int i=1;i&lt;=n;i++)if(!vis[i])ans+=solve(i); printf(&quot;%lld&quot;,ans); return 0; } 这应该是这道题最丑最长的一份代码，为了求环跑了一遍dfs，为了标记跑了一遍dfs，为了求前缀和又跑了一遍dfs，特判还有一遍dfs","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://tian-xing.github.io/tags/DP/"},{"name":"树","slug":"树","permalink":"https://tian-xing.github.io/tags/%E6%A0%91/"},{"name":"DFS","slug":"DFS","permalink":"https://tian-xing.github.io/tags/DFS/"}],"author":"Tian-Xing"},{"title":"2-SAT问题","slug":"2-SAT问题","date":"2019-10-21T01:06:56.000Z","updated":"2020-01-15T23:47:01.910Z","comments":true,"path":"2019/10/21/2-SAT问题/","link":"","permalink":"https://tian-xing.github.io/2019/10/21/2-SAT%E9%97%AE%E9%A2%98/","excerpt":"只会做模板题嘤","text":"只会做模板题嘤 所谓$2-sat$问题，其实是$k-sat$问题的一种特殊形式。 以下是$k-sat$问题的粗略解释。 一共有一些人 每人有$k$个不同的要求 现在求一种方案使每个人的要求都能被至少满足一个（这个解释好像不太严谨吧 $2-sat$问题更严谨的解释： 有$n$个布尔变量$x_1$~$x_n$,另有$m$个需要满足的条件， 每个条件的形式都是“$x_i$为$true/false$或$x_j$为$true/flase$”。 比如“$x_1$为真或$x_3$为假”、“$x_7$为假或$x_2$为假”。$2-sat$问题的目标是给每个变量赋值使得所有条件得到满足。 那么，我们发现所有的条件其实可以书写成$a\\vee b$的形式。 接着，我们把它变形就可以得到$\\lnot a\\rightarrow$ $b \\wedge \\lnot b \\rightarrow a$ 为什么呢？因为$a$和$b$两个条件取其中之一满足时，如果$a$不满足，则$b$一定满足。如果$b$不满足，则$a$一定满足。但是a满足不能推出b不满足 所以我们现在可以建一个有向图惹。如果$a$与$b$相连，则$a$可以推出$b$。 判断IMPOSSIBLE的情况： 先对有向图进行缩点，如果$x$和$\\lnot x$在同一个强连通分量里，那就是不可能的情况。因为同一个强连通分量里的各个点之间都有连接的路径，所以各个布尔值互相都可以推出。这样的话$x$和$\\lnot x$就必须同时满足，但显然这是不可能的。所以IMPOSSIBLE 如何求解每个布尔变量的值： 显然，当我们进行缩点之后，原本的图就变成了一张$DAG$，那么此时我们就可以进行拓扑排序惹。有一点很显然就是拓扑序靠后的一定是有拓扑序靠前的推出来的。所以如果一个布尔变量满足，则拓扑序比他靠后的布尔变量一定也满足。所以我们只要判断每个$x$和$\\lnot x$的拓扑序就行了，如果$x$的拓扑序比$\\lnot x$的拓扑序靠后，那么此布尔变量取$1$，否则取$0$。 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; #define N 2000050 #define M 1000050 int head[N],num,low[N],dfn[N],dfx,co[N],col,st[N],top,n,m,val[N]; struct node { int next,to; }tu[M*2]; void addedge(int u,int v) { tu[++num]=(node){head[u],v}; head[u]=num; } void tarjan(int u) { low[u]=dfn[u]=++dfx; st[++top]=u; for(int i=head[u];i;i=tu[i].next) { int v=tu[i].to; if(!dfn[v]) { tarjan(v); low[u]=min(low[u],low[v]); } else if(!co[v])low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { co[u]=++col; while(st[top]!=u) { co[st[top]]=col; top--; } top--; } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b,c,d; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); addedge(a+(b^1)*n,c+d*n); addedge(c+(d^1)*n,a+b*n); } for(int i=1;i&lt;=n*2;i++)if(!dfn[i])tarjan(i); for(int i=1;i&lt;=n;i++)if(co[i+n]==co[i]){printf(&quot;IMPOSSIBLE&quot;);return 0;} printf(&quot;POSSIBLE\\n&quot;); for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,co[i]&gt;co[i+n]); }","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"https://tian-xing.github.io/tags/Tarjan/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://tian-xing.github.io/tags/2-SAT/"}],"author":"Tian-Xing"},{"title":"CF286C Main Sequence","slug":"CF286C Main Sequence","date":"2019-10-07T13:40:50.000Z","updated":"2019-12-29T03:53:33.950Z","comments":true,"path":"2019/10/07/CF286C Main Sequence/","link":"","permalink":"https://tian-xing.github.io/2019/10/07/CF286C%20Main%20Sequence/","excerpt":"栈真是和括号完美结合的数据结构呢","text":"栈真是和括号完美结合的数据结构呢 看到此题中的括号一词，我们不难想到栈这个东西 因为有左括号，则必有右括号 因为后扫到的左括号先和右括号匹配，所以可以用栈维护 那么我们就从右边开始向左边扫，扫到一个位置不能和栈顶元素匹配或者已经被钦定为右括号，就把他丢进右括号的栈里 为什么从右边开始扫呢？ 因为题目给出的是钦定的右括号，也就是说这些位置一定是右括号 如果从左边开始则不能很好的满足这些数是右括号的条件 所以从右边开始贪心即可 若扫到的元素不能和栈顶元素匹配，如果把它和别的元素匹配，就会导致一个括号被忽略的情况，所以不能和栈顶匀速匹配就进栈 方案的话如果是右括号就是$-$，左括号就是$+$ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define int long long int n,m,top=0; int a[2000050],stack[2000050],b[2000050],answer[2000050]; signed main() { scanf(&quot;%lld&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); scanf(&quot;%lld&quot;,&amp;m); int x; for(int i=1;i&lt;=m;i++)scanf(&quot;%lld&quot;,&amp;x),b[x]=1; for(int i=n;i&gt;=1;i--) { if(a[i]!=stack[top] || b[i]==1)stack[++top]=a[i],answer[i]=-1; else top--,answer[i]=1; } if(top)printf(&quot;NO&quot;); if(!top)printf(&quot;YES\\n&quot;); if(!top)for(int i=1;i&lt;=n;i++)printf(&quot;%lld &quot;,answer[i]*a[i]); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://tian-xing.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"栈","slug":"栈","permalink":"https://tian-xing.github.io/tags/%E6%A0%88/"}],"author":"Tian-Xing"},{"title":"贪心算法经典例题","slug":"贪心算法经典例题","date":"2019-09-28T08:09:10.000Z","updated":"2020-01-15T23:47:14.483Z","comments":true,"path":"2019/09/28/贪心算法经典例题/","link":"","permalink":"https://tian-xing.github.io/2019/09/28/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/","excerpt":"贪心算法真是令人头疼的一个模块啊,考场上怎么想都想不出来,代码却常常很短……","text":"贪心算法真是令人头疼的一个模块啊,考场上怎么想都想不出来,代码却常常很短…… 仓库选址 描述在一条数轴上有N家商店，它们的坐标分别为 A[1]-A[N]。现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。输入格式第一行一个整数N，第二行N个整数A[1]-A[N]。输出格式一个整数，表示距离之和的最小值。样例输入46 2 9 1样例输出12数据范围与约定对于100%的数据: N&lt;=100000, A[i]&lt;=1000000 这道题的答案其实就是所有点距离的中位数我们来证明一下假设我们所有点中距离中位数的点是k那么答案就是$\\sum_{i=1}^n(a[i]-a[k])$假设有另外一个点比它更优，这个点为q那么我们一定可以通过平移点k来得到点q假如我们平移U点，U点左边有left个点，右边有right个点,那么右移后新的答案会加left乘平移距离，减right乘平移距离，左移后新的答案会加right乘平移距离，减left乘平移距离若需将k左移则必定有left&gt;right那么必定k点比q点更优，右移同理综上，答案就是所有点距离的中位数 均分纸牌 题目描述 Description有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。 移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。 例如 N=4，4 堆纸牌数分别为： ① 9 ② 8 ③ 17 ④ 6 移动3次可达到目的： 从 ③ 取 4 张牌放到 ④ （9 8 13 10） -&gt; 从 ③ 取 3 张牌放到 ②（9 11 10 10）-&gt; 从 ② 取 1 张牌放到①（10 10 10 10）。输入描述 Input Description第一行N（N 堆纸牌，1 &lt;= N &lt;= 100）第二行A1 A2 … An （N 堆纸牌，每堆纸牌初始数，l&lt;= Ai &lt;=10000）输出描述 Output Description输出至屏幕。格式为：所有堆均达到相等时的最少移动次数。样例输入 Sample Input49 8 17 6样例输出 Sample Output3 首先我们可以看出，如果所有纸牌数量加起来的和除以人数不是整数的话，此题无解所以均分纸牌后，每个人手里都有纸牌数的平均数个纸牌。那么我们只需要从第一个人开始依次向后面递推模拟即可 如果下一个人的纸牌数量比平均数多，那么就从当前人向下一个人移动纸牌如果当前的的人的纸牌数量比平均数少，就从下一个人手里取走纸牌按此规则进行模拟即可 用s数组存纸牌数量的前缀和这时我们发现其实答案就是$\\sum_{i=1}^nabs(s[i]-i*平均数)$显然我们在模拟到k个的时候前面k-1个都已经均分好了，只需处理第k个，按照规则进行转移即可那这样我们发现一个等价做法，我们可以在前缀和之前就将纸牌数量都减少平均数个显然a数组现在表示纸牌与其他纸牌堆的差值再把处理后的a数组前缀和的绝对值加起来即可之所以前缀和是因为前面的纸牌的移动会对后面造成影响 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; int n; int a[500050],s[500050]; int abs(int x) { return x&gt;0?x:-x; } int main() { scanf(&quot;%d&quot;,&amp;n); int zws=0; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]),zws+=a[i]; zws/=n; int answer=0; for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+a[i],answer+=i*zws!=s[i]?1:0; printf(&quot;%d&quot;,answer); return 0; } 环形均分纸牌 题目描述有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。输入格式小朋友个数n 下面n行 ai输出格式求使所有人获得均等糖果的最小代价。输入输出样例输入41254输出4 我们考虑环形均分纸牌可以进行破环成链，那么一个环就有环上点个数种情况(可以从任意点断开)用a表示减去平均数之后的纸牌数量，s表示对a的前缀和假设从k处断开，那么这个环就断成了一条链…………………………a[k+1] s[k+1]-s[k]a[k+2] s[k+2]-s[k]…………………………a[n] s[n]-s[k]a[1] s[1]+s[n]-s[k]…………………………a[k] s[k]+s[n]-s[k]因为此处a数组已经减去平均数了，所以s[n]=0也就是说，答案是$\\sum_{i=1}^n(s[i]-s[k])$此时我们只要找到最小的k就可以了，我们发现现在的情况和前面提到的货仓选址问题一模一样所以k就是s数组的中位数 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define ll long long ll n; ll a[5000050],s[5000050]; ll abss(ll x) { if(x&gt;0)return x; else return -x; } int main() { scanf(&quot;%d&quot;,&amp;n); ll pjs=0; for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),pjs+=a[i]; pjs/=n; for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+a[i]-pjs; sort(s+1,s+n+1); int k=n/2; ll answer=0; for(int i=1;i&lt;=n;i++)answer+=abss(s[i]-s[k]); printf(&quot;%lld&quot;,answer); return 0; }","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://tian-xing.github.io/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Tian-Xing"},{"title":"洛谷P2783 有机化学之神偶尔会作弊","slug":"洛谷P2783 有机化学之神偶尔会作弊","date":"2019-09-08T02:32:02.000Z","updated":"2019-12-29T03:44:52.360Z","comments":true,"path":"2019/09/08/洛谷P2783 有机化学之神偶尔会作弊/","link":"","permalink":"https://tian-xing.github.io/2019/09/08/%E6%B4%9B%E8%B0%B7P2783%20%E6%9C%89%E6%9C%BA%E5%8C%96%E5%AD%A6%E4%B9%8B%E7%A5%9E%E5%81%B6%E5%B0%94%E4%BC%9A%E4%BD%9C%E5%BC%8A/","excerpt":"我刚做完这题就掉紫了","text":"我刚做完这题就掉紫了 这道题的题意非常的显然，所以我们只要直接按照题意做一遍就好了。 最后求两点之间距离的时候，求一个$LCA$即可，答案就是$d[a]+d[b]-2* d[lca(a,b)]+1$ 所以这道题就做完了(雾 边双联通分量有有两种方法，其中一种是求出所有割边，然后依次删去。这样剩下的图就被分成了很多单独的部分，每一个部分就是一个$e-DCC$ 另一种方法则和有向图的缩点相似，我们用一个栈记录搜索树上的点，当$low[x]=dfn[x]$的时候将$stack$里的点依次退出，一直退到$x$，我们便求出了一个$e-DCC$ 最下方题面里说两个点不删去所以当我们$tarjan$的时候遇到$x$的父亲就直接$continue$,按这个思路法二可以过。 但是法一即使加上这个判断也过不了，所以还是不写法一比较好(雾 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; #define N 100500 #define M 500500 int stack[N],top,ttt,n,m,head[N],num=1,dfn[N],low[N],cnt,bridge[M],he[N],sy[N],numm,t,f[100050][50],d[N]; queue&lt;int&gt; q; struct node { int next,to; }edge[M*2],tu[M*2]; void addedge(int u,int v) { edge[++num]=(node){head[u],v}; head[u]=num; } void newaddedge(int u,int v) { tu[++numm]=(node){he[u],v}; he[u]=numm; } void tarjan(int x,int fa) { low[x]=dfn[x]=++cnt; stack[++top]=x; for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(v==fa)continue; if(!dfn[v]) { tarjan(v,x); low[x]=min(low[x],low[v]); } else low[x]=min(low[x],dfn[v]); } if(low[x]==dfn[x]) { sy[x]=++ttt; while(stack[top]!=x)sy[stack[top]]=ttt,top--; top--; } } void jb(int x) { sy[x]=cnt; for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(bridge[i]||sy[v])continue; jb(v); } } void bfs() { q.push(1); d[1]=1; while(!q.empty()) { int u=q.front(); q.pop(); for(int i=he[u];i;i=tu[i].next) { int v=tu[i].to; if(d[v])continue; d[v]=d[u]+1; f[v][0]=u; for(int k=1;k&lt;=t;k++)f[v][k]=f[f[v][k-1]][k-1]; q.push(v); } } } int lca(int a,int b) { if(d[a]&lt;d[b])swap(a,b); for(int i=t;i&gt;=0;i--)if(d[f[a][i]]&gt;=d[b])a=f[a][i]; if(a==b)return a; for(int i=t;i&gt;=0;i--)if(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i]; return f[a][0]; } void xs(int shu) { int answer[500000],kkk=0; while(shu) { answer[++kkk]=shu%2; shu/=2; } for(int i=kkk;i&gt;=1;i--)printf(&quot;%d&quot;,answer[i]); printf(&quot;\\n&quot;); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v);addedge(v,u); } for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i,0); cnt=0; // for(int i=1;i&lt;=n;i++)if(!sy[i]){++cnt;jb(i);} for(int i=2;i&lt;=num;i++)if(sy[edge[i].to]!=sy[edge[i^1].to])newaddedge(sy[edge[i].to],sy[edge[i^1].to]); t=32; bfs(); int tot; scanf(&quot;%d&quot;,&amp;tot); for(int i=1;i&lt;=tot;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a=sy[a];b=sy[b]; int lcab=lca(a,b); xs(d[a]+d[b]-2*d[lcab]+1); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"https://tian-xing.github.io/tags/Tarjan/"},{"name":"双连通分量","slug":"双连通分量","permalink":"https://tian-xing.github.io/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}],"author":"Tian-Xing"},{"title":"SCOI2016 背单词","slug":"SCOI2016 背单词","date":"2019-09-03T13:50:41.000Z","updated":"2019-12-29T03:53:09.740Z","comments":true,"path":"2019/09/03/SCOI2016 背单词/","link":"","permalink":"https://tian-xing.github.io/2019/09/03/SCOI2016%20%E8%83%8C%E5%8D%95%E8%AF%8D/","excerpt":"dfs序最优性的证明真是曲折呢","text":"dfs序最优性的证明真是曲折呢 给你一些字符串，让你对其进行排列，使得按以下规则花费最少(然而题意真的不清楚，很容易就让人以为字符串的顺序是排好的) （$x$为字符串在自行排定的序列中的位置，当前字符串为$a$)$1.$如果$a$存在后缀且a的后缀在a之后，花费$+=n^2$$2.$如果$a$不存在后缀则花费$+=x$$3.$设$y$为$a$之前离其最近的是$a$的后缀的字符串的位置，$a$存在后缀且$a$的后缀在$a$之前，则花费$+=x-y$ 经过转化题意就比较显然了，但是我们如果仔细读题我们发现$1，2$规则其实完全没有必要。 规则1我们只要把$a$的后缀放在$a$之前就好了，这样肯定优于放在$a$的后面因为$x-y$的值最大只能是n-1显然优于$n^2$ 规则2我们发现其实就是规则三中$y=0$的特殊情况，直接当规则3来处理就好 看到后缀我们显然首先想到的是后缀数组，但是本蒟蒻太弱了不会怎么办？？？（而且本蒟蒻也不知道本题能不能用后缀数组） 我们把字符串翻个顺序就会发现后缀其实就是前缀，所以我们可以翻转字符串，处理前缀。 而处理前缀我们首先就会想到$trie$字典树，所以本题我们采用建立$trie$字典树的做法。 看懂题目的规则之后我们发现可以贪心的求解此题，只要让字符串的后缀与字符串之间所隔的字符串数目最小即可 所以第一步我们建立一颗$trie$树 第二步我们发现一个字符串有可能有很多后缀，所以我们需要判重，这里使用并查集 由于字符串的后缀与字符串之间存在有向的关系，便建立一张有向图。$x-&gt;y$代表$x$是$y$的后缀 因为要保证字符串与字符串的后缀之间距离最小所以贪心的选取以x为根的最小的子树 （使用vector在算出每棵子树大小后进行排序即可）最后按照规则求和 如果你有认真看我的或其他人的题解，你可以发现我们在最后求和的时候是按照dfs序的。那么为什么？（我不会） 所以我在夏令营时找了wqy神仙请教。 考虑建出一棵树之后，对于构建的任意合法的序列，都满足$i$的父亲一定在$i$之前出现，$i$的孩子们都一定在$i$之后出现 先尝试证明$dfs$序一定最优，对于以同一深度的节点为根的子树，在一颗中找一个叶子节点$j$,在另一颗里找一个根节点$i$(当前序列中$j$所在的子树的根在$i$之前出现 假设$j&lt;i$的时候代价最小，尝试将$j$放在$i$的后面，此时$i&lt;j$。那么我们发现如果$j$放在$i$与$i$的孩子们之间，$i$的孩子们和$i$的距离都会加$1$，所以总代价会增加，而$j$和$j$的父亲的距离一定也会增加，所以总代价也会增加 所以对于$j$所在子树的根比$i$在序列中出现的早的情况，$j&lt;i$的情况是最优的 那么每个子树形成了一段连续的区间，对于每个节点进行调整，最后我们发现形成了一个$dfs$序(有时别的序列也会和$dfs$序列一样优秀，但是此处证明的是$dfs$序列是最优解之一，不是唯一解 接下来再证明先遍历子树小的更优秀。 $WQY$:月明风清 $21:28:04$因为你所有的$size$排序之后 月明风清 $21:28:17$第$i$个根节点的贡献是前面所有树的$size$之和所以要排序 综上所述，当我们进行$dfs$序且按子树大小排序时，求出代价即为最优。 $Q.E.D$ 感谢$wqy$，给了我很大的帮助wucstdio #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; #define N 510050 #define M 100050 #define ll long long ll ans=0; char x[N]; int n,cnt,bo[N],tot=1,trie[5000050][27],fa[N],id[N],son[N],num; vector&lt;int&gt;tu[N]; int read() { int s=0,p=1; char ch=getchar(); while(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if(ch==&#39;-&#39;)p=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48); ch=getchar(); } return s*p; } int find(int x) { if(fa[x]==x)return fa[x]; else return fa[x]=find(fa[x]); } void insert(char *s,int bh) { int l=strlen(s); int u=1; for(int i=l-1;i&gt;=0;i--) { int c=s[i]-&#39;a&#39;; if(!trie[u][c])trie[u][c]=++tot; u=trie[u][c]; } bo[u]=bh; } void make(int x) { for(int i=0;i&lt;26;i++) { int v=trie[x][i]; if(v) { if(!bo[v]) { fa[v]=find(x); } else { tu[bo[find(x)]].push_back(bo[v]); } make(v); } } } int cmp(int x,int y) { return son[x]&lt;son[y]; } void sonsum(int x) { son[x]=1; for(vector&lt;int&gt; :: iterator it=tu[x].begin();it!=tu[x].end();it++) { int v=*it; sonsum(v); son[x]+=son[v]; } sort(tu[x].begin(),tu[x].end(),cmp); } void dfs(int x) { id[x]=num++; for(vector&lt;int&gt; :: iterator it=tu[x].begin();it!=tu[x].end();it++) { int v=*it; ans+=num-id[x]; dfs(v); } } void dfss(int x) { for(vector&lt;int&gt; :: iterator it=tu[x].begin();it!=tu[x].end();it++) { int v=*it; cout&lt;&lt;v&lt;&lt;endl; dfss(v); } } int main() { n=read(); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,x); insert(x,i); } for(int i=1;i&lt;=tot;i++)fa[i]=i; make(1); sonsum(0);dfs(0); printf(&quot;%lld&quot;,ans); return 0; } 并查集去重的思路来源于此篇blog","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://tian-xing.github.io/tags/DFS/"},{"name":"并查集","slug":"并查集","permalink":"https://tian-xing.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"TRIE","slug":"TRIE","permalink":"https://tian-xing.github.io/tags/TRIE/"}],"author":"Tian-Xing"},{"title":"洛谷P1020 导弹拦截","slug":"洛谷P1020 导弹拦截","date":"2019-09-02T12:56:56.000Z","updated":"2019-12-29T03:56:38.925Z","comments":true,"path":"2019/09/02/洛谷P1020 导弹拦截/","link":"","permalink":"https://tian-xing.github.io/2019/09/02/%E6%B4%9B%E8%B0%B7P1020%20%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/","excerpt":"小蒟蒻获得的赞最多的一篇题解","text":"小蒟蒻获得的赞最多的一篇题解 第一问很容易就可以想到是求一个最长不上升子序列 但是第二问就需要一个转换的思想了 我们可以把问题中需要几组导弹转化成求一个最长上升子序列 证明： 首先我们把这些导弹分为$s$组($s$即为所求答案) 可以看出每一组都是一个不升子序列 划分完后我们在组一里找一个原序列里以组一的开头点连续的不升子串的最后一个元素，可以知道在组2中一定有一个大与它的点 (如果组二中没有的话，那么组二中最高的导弹高度必然小于这个点，而其他的高度都小于这个高度而且是递减或相等的，那么没有必要再开一个组二了，矛盾，所以不存在找不到比他大的点的情况) 以此类推，对于每一个$k$组$(1&lt;=k&lt;n)$都可以找到这样的一些点 所以把这些点连起来，就是一条上升子序列。 设最长上升子序列长度为$l$ 所求上升子序列为$h$ 那么$h&lt;=l$ 因为最长上升子序列任意两个不在一组内 (如果在同一个组内，则每个组的数不成为一个不生子序列，矛盾） 所以$l==h$ 比较难理解 我们来看组数据 $389 207 155 300 299 170 158 65$ 组一 $389 207 155 65$组二 $300 299 170 158$ 步骤一中我们一开始找到的点是$1$ 因为如果找$65$不好解释，所以我们找原数列里连续的最后一个即$155$ 组二里可以找到$300$比他大 所以最长上升子序列长度为$2==$答案 到这里我们发现只要求最长不升子序列和最长上升子序列就好了 下面说最长上升子序列的$O(nlogn)$求法（最长不升子序列同理） 数组$a$为要求的数列 首先我们开一个数组$k$ $k[lis]$记录$lis$长的上升子序列的最后一个数 $len$表示最长的长度 初始化$len=0，k[0]=-$无限 我们可以很轻松的看出k是一个有序的（递增） 如果$ai&gt;k[len]$ $k[len=1]=i$ 不然每次在k里面二分查找第一个大于等于它的数，下标为$x$ 比较大小，$k[x]=min(k[x],a[i])$ 因为我们要求最长的，所以我们要尽可能的让最后一位小（贪心思想） 最后输出$len$即可 证明 $k$数组一定是一个有序的上升序列 因为它记录的是长为$x$的上升序列的最后一位 如果不是上升的，那么它必然可以加入以$k[x+1]$结尾的上升序列，矛盾 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int i,g[10000000],a[10000000],len,k[10000000],zen; const int inf=0x7f7f7f7f; int main() { g[0]=-inf; k[0]=inf; while(cin&gt;&gt;a[++i]) { if(a[i]&lt;=k[zen]){zen++;k[zen]=a[i];} else { int h=0,d=zen,mid; while(h&lt;d) { mid=(h+d)&gt;&gt;1; if(k[mid]&gt;=a[i]) h=mid+1; else d=mid; }//二分在k数组里找第一个小于a[i]的数 k[h]=max(k[h],a[i]);//进行比较，贪心思想 } if(a[i]&gt;g[len]) { len++; g[len]=a[i]; continue; } int x=0,y=len,mid; while(x&lt;y) { mid=(x+y)&gt;&gt;1; if(g[mid]&gt;=a[i]) y=mid; else x=mid+1; }//二分在g数组里找第一个大于等于a[i]的数 g[x]=min(g[x],a[i]);//进行比较，贪心思想 } cout&lt;&lt;zen&lt;&lt;endl&lt;&lt;len; return 0; } 文章中关于对求最长上升子序列的证明，部分参考了这位大佬的题解，致以最诚挚的感谢jjpjj的证明方法 谨以此题纪念我的luogu绿名","categories":[{"name":"题解","slug":"题解","permalink":"https://tian-xing.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://tian-xing.github.io/tags/DP/"},{"name":"二分答案","slug":"二分答案","permalink":"https://tian-xing.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}],"author":"Tian-Xing"},{"title":"Tian-Xing的任务计划","slug":"Tian-Xing的任务计划","date":"2019-08-27T23:42:57.000Z","updated":"2020-01-15T23:47:26.834Z","comments":true,"path":"2019/08/28/Tian-Xing的任务计划/","link":"","permalink":"https://tian-xing.github.io/2019/08/28/Tian-Xing%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/","excerpt":"难以完成的任务计划~","text":"难以完成的任务计划~ emmmmm小蒟蒻真是不知道该学什么好了毕竟没学过的东西太多了点马上就要csp2019了真心自闭目前的任务计划：1.复习完DP2.复习完图论3.复习完基础数据结构4.学习分块5.学习莫队6.学习网络流7.学习概率DP","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[],"author":"Tian-Xing"},{"title":"Tian-Xing犯过的错误","slug":"Tian-Xing犯过的错误","date":"2019-08-27T23:42:40.000Z","updated":"2020-01-15T23:47:33.523Z","comments":true,"path":"2019/08/28/Tian-Xing犯过的错误/","link":"","permalink":"https://tian-xing.github.io/2019/08/28/Tian-Xing%E7%8A%AF%E8%BF%87%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"曾经犯过的傻逼错误~","text":"曾经犯过的傻逼错误~ 1.线段树pushdown一定要分开写，遇见有关精度的问题一定要先把有关精度的变量预处理成一个变量，不能一边算一边做2.数学题记得不停地用模数取模防止爆long long，保险起见用快速乘 ll mul(ll a,ll b,ll p) { return (a*b-(ll)((long double)a/p*b)*p+p)%p; } 3.spfa记得vis[u]=04.倍增求LCA记得从大到小的顺序跳，还要避免变量名冲突,记得初始节点深度是15.广搜的时候记得把v加入队列6.可并堆记得使用并查集路径压缩维护7.合并并查集使用启发式合并8.写spfa时记得加小优化：把队尾的值与队首+1的值比较，较小的扔前面，较大的扔后面9.dp时记得初始化，数组下标要注意，千万不要越界10.结构体里的二维数组不要开太大会爆掉11.2019洛谷秋令营模拟赛tB，我将minn的初值赋为了1e9，开心的拿到了10pts的好成绩，比赛后我觉得算法比较正确，将minn的初值改为了9999999999999999，于是拿到了100pts的好成绩12.还是那场比赛(真是降智 TA的滚动数组没有清零…… 所以这是血的教训：滚动数组记得要清零13.线段树记得询问和修改不要把(l,r)和(x,y)区间写反14.主席树向函数里传递root[x]而不是x15.写数论分块时循环里的变量记得开long long16.写tarjan的时候如果有多组数据记得清空stack和top17.三目运算符里面最好只写一条语句，多条语句写if","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[],"author":"Tian-Xing"},{"title":"Tian-Xing见过的定理","slug":"Tian-Xing见过的定理","date":"2019-08-27T23:42:08.000Z","updated":"2020-01-15T23:47:38.981Z","comments":true,"path":"2019/08/28/Tian-Xing见过的定理/","link":"","permalink":"https://tian-xing.github.io/2019/08/28/Tian-Xing%E8%A7%81%E8%BF%87%E7%9A%84%E5%AE%9A%E7%90%86/","excerpt":"经常忘记的数学定理~","text":"经常忘记的数学定理~ $n!$的质因数分解定理定理:对于小于$n$的质数$p$，$n!$中含有因子$p$的个数为: $$n/p+n/p^2+…+n/p^k(其中k为p^k&lt;=n的最大值)$$ 约数和对于一个数$N$，如果它的标准分解式为 $$N=p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_n^{a_n}$$ 那么约数和为 $$S=\\prod_{i=1}^n\\sum_{j=0}^{a_i}p_i^j(p_1,p_2……p_n为质数)$$ 那么约数个数为 $$S=\\prod_{i=1}^n(a_i+1)$$ 威尔逊定理当且仅当$p$是素数时 $$(p-1)! \\equiv p-1(\\mod p)$$ 考虑如果这$p-1$个数中如果一个数是一个数的逆元那么这两个数都会被消去，留下的都是逆元是本身的数。 若一个数的逆元等于本身，则有 $$x \\equiv x^{-1} ( \\mod p)$$ 那么两边平方，移项，则有 $$x^2 \\equiv 1 ( \\mod p)$$ $$x^2-1\\equiv 0 ( \\mod p)$$ $$(x+1)(x-1) \\equiv 0 ( \\mod p)$$ 所以$p|(x+1)(x-1)$，由于$p$是质数，所以$x$只能是$1$或$p-1$。 $$Q.E.D.$$ 判断两个大数相等选取适当个大质数，如果两个数$mod$选取的所有的质数都相等则两个大数有很大概率相等。 勾股数组勾股方程即形如$a^2+b^2=c^2$的方程。 勾股方程的所有正整数解都可以被表示为下图的形式 $$a=\\frac{d(u^2-v^2)}{2},b=duv,c=\\frac{d(u^2+v^2)}{2}(gcd(u,v)=1)$$ 不明定理$$(\\sum_{i=1}^n i)^2=\\sum_{i=1}^n i^3$$","categories":[{"name":"笔记","slug":"笔记","permalink":"https://tian-xing.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[],"author":"Tian-Xing"}]}